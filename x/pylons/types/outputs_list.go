package types

import (
	"fmt"
	"math/rand"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/google/cel-go/cel"
)

// WeightedParam is to make structs which is using weight to be based on
type OutputsList struct {
	Result []int
	Weight string
}

func (ol OutputsList) String() string {
	return fmt.Sprintf("OutputsList{Result: %v, Weight: %v}", ol.Result, ol.Weight)
}

func (ol OutputsList) GetWeight(env cel.Env, variables map[string]interface{}, funcs cel.ProgramOption) (int, error) {
	refVal, refErr := CheckAndExecuteProgram(env, variables, funcs, ol.Weight)
	if refErr != nil {
		return 0, refErr
	}

	val64, ok := refVal.Value().(int64)
	if !ok || val64 < 0 {
		return 0, nil
	}
	return int(val64), nil
}

// WeightedOutputsList is a struct to keep items which can be generated by weight;
// ItemOutput and CoinOutput is possible in current stage
type WeightedOutputsList []OutputsList

func (wpl WeightedOutputsList) String() string {
	itm := "WeightedOutputsList{"

	for _, output := range wpl {
		itm += output.String() + ",\n"
	}

	itm += "}"
	return itm
}

func (wol WeightedOutputsList) Actualize(env cel.Env, variables map[string]interface{}, funcs cel.ProgramOption) ([]int, sdk.Error) {
	lastWeight := 0
	var weights []int
	for _, wp := range wol {
		w, err := wp.GetWeight(env, variables, funcs)
		if err != nil {
			return nil, sdk.ErrInternal(err.Error())
		}
		lastWeight += w
		weights = append(weights, lastWeight)
	}
	if len(wol) == 0 {
		return nil, nil
	}

	if lastWeight == 0 {
		return nil, sdk.ErrInternal("total weight of weighted param list shouldn't be zero")
	}
	randWeight := rand.Intn(lastWeight)

	first := 0
	chosenIndex := -1
	for i, weight := range weights {
		if randWeight >= first && randWeight <= weight {
			chosenIndex = i
			break
		}
		first = weight
	}
	return wol[chosenIndex].Result, nil
}

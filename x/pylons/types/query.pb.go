// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pylons/query.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CoinInputList struct {
	Coins []*CoinInput `protobuf:"bytes,1,rep,name=coins,proto3" json:"coins,omitempty"`
}

func (m *CoinInputList) Reset()         { *m = CoinInputList{} }
func (m *CoinInputList) String() string { return proto.CompactTextString(m) }
func (*CoinInputList) ProtoMessage()    {}
func (*CoinInputList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{0}
}
func (m *CoinInputList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinInputList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinInputList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinInputList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinInputList.Merge(m, src)
}
func (m *CoinInputList) XXX_Size() int {
	return m.Size()
}
func (m *CoinInputList) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinInputList.DiscardUnknown(m)
}

var xxx_messageInfo_CoinInputList proto.InternalMessageInfo

func (m *CoinInputList) GetCoins() []*CoinInput {
	if m != nil {
		return m.Coins
	}
	return nil
}

type CoinInput struct {
	Coin  string `protobuf:"bytes,1,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Count int64  `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *CoinInput) Reset()         { *m = CoinInput{} }
func (m *CoinInput) String() string { return proto.CompactTextString(m) }
func (*CoinInput) ProtoMessage()    {}
func (*CoinInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{1}
}
func (m *CoinInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinInput.Merge(m, src)
}
func (m *CoinInput) XXX_Size() int {
	return m.Size()
}
func (m *CoinInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinInput.DiscardUnknown(m)
}

var xxx_messageInfo_CoinInput proto.InternalMessageInfo

func (m *CoinInput) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CoinInput) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type CoinOutput struct {
	ID    string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Coin  string `protobuf:"bytes,2,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Count string `protobuf:"bytes,3,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *CoinOutput) Reset()         { *m = CoinOutput{} }
func (m *CoinOutput) String() string { return proto.CompactTextString(m) }
func (*CoinOutput) ProtoMessage()    {}
func (*CoinOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{2}
}
func (m *CoinOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinOutput.Merge(m, src)
}
func (m *CoinOutput) XXX_Size() int {
	return m.Size()
}
func (m *CoinOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinOutput.DiscardUnknown(m)
}

var xxx_messageInfo_CoinOutput proto.InternalMessageInfo

func (m *CoinOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *CoinOutput) GetCoin() string {
	if m != nil {
		return m.Coin
	}
	return ""
}

func (m *CoinOutput) GetCount() string {
	if m != nil {
		return m.Count
	}
	return ""
}

type SemVer struct {
	Number string `protobuf:"bytes,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *SemVer) Reset()         { *m = SemVer{} }
func (m *SemVer) String() string { return proto.CompactTextString(m) }
func (*SemVer) ProtoMessage()    {}
func (*SemVer) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{3}
}
func (m *SemVer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemVer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemVer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemVer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemVer.Merge(m, src)
}
func (m *SemVer) XXX_Size() int {
	return m.Size()
}
func (m *SemVer) XXX_DiscardUnknown() {
	xxx_messageInfo_SemVer.DiscardUnknown(m)
}

var xxx_messageInfo_SemVer proto.InternalMessageInfo

func (m *SemVer) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

type Level struct {
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *Level) Reset()         { *m = Level{} }
func (m *Level) String() string { return proto.CompactTextString(m) }
func (*Level) ProtoMessage()    {}
func (*Level) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{4}
}
func (m *Level) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Level) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Level.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Level) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Level.Merge(m, src)
}
func (m *Level) XXX_Size() int {
	return m.Size()
}
func (m *Level) XXX_DiscardUnknown() {
	xxx_messageInfo_Level.DiscardUnknown(m)
}

var xxx_messageInfo_Level proto.InternalMessageInfo

func (m *Level) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

type Email struct {
	Str string `protobuf:"bytes,1,opt,name=str,proto3" json:"str,omitempty"`
}

func (m *Email) Reset()         { *m = Email{} }
func (m *Email) String() string { return proto.CompactTextString(m) }
func (*Email) ProtoMessage()    {}
func (*Email) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{5}
}
func (m *Email) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Email) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Email.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Email) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Email.Merge(m, src)
}
func (m *Email) XXX_Size() int {
	return m.Size()
}
func (m *Email) XXX_DiscardUnknown() {
	xxx_messageInfo_Email.DiscardUnknown(m)
}

var xxx_messageInfo_Email proto.InternalMessageInfo

func (m *Email) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

type FloatString struct {
	Str string `protobuf:"bytes,1,opt,name=str,proto3" json:"str,omitempty"`
}

func (m *FloatString) Reset()         { *m = FloatString{} }
func (m *FloatString) String() string { return proto.CompactTextString(m) }
func (*FloatString) ProtoMessage()    {}
func (*FloatString) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{6}
}
func (m *FloatString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatString.Merge(m, src)
}
func (m *FloatString) XXX_Size() int {
	return m.Size()
}
func (m *FloatString) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatString.DiscardUnknown(m)
}

var xxx_messageInfo_FloatString proto.InternalMessageInfo

func (m *FloatString) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

// DoubleInputParam describes the bounds on an item input/output parameter of type float64
type DoubleInputParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The minimum legal value of this parameter.
	MinValue *FloatString `protobuf:"bytes,2,opt,name=MinValue,proto3" json:"MinValue,omitempty"`
	// The maximum legal value of this parameter.
	MaxValue *FloatString `protobuf:"bytes,3,opt,name=MaxValue,proto3" json:"MaxValue,omitempty"`
}

func (m *DoubleInputParam) Reset()         { *m = DoubleInputParam{} }
func (m *DoubleInputParam) String() string { return proto.CompactTextString(m) }
func (*DoubleInputParam) ProtoMessage()    {}
func (*DoubleInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{7}
}
func (m *DoubleInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleInputParam.Merge(m, src)
}
func (m *DoubleInputParam) XXX_Size() int {
	return m.Size()
}
func (m *DoubleInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleInputParam proto.InternalMessageInfo

func (m *DoubleInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DoubleInputParam) GetMinValue() *FloatString {
	if m != nil {
		return m.MinValue
	}
	return nil
}

func (m *DoubleInputParam) GetMaxValue() *FloatString {
	if m != nil {
		return m.MaxValue
	}
	return nil
}

type DoubleInputParamList struct {
	Params []*DoubleInputParam `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty"`
}

func (m *DoubleInputParamList) Reset()         { *m = DoubleInputParamList{} }
func (m *DoubleInputParamList) String() string { return proto.CompactTextString(m) }
func (*DoubleInputParamList) ProtoMessage()    {}
func (*DoubleInputParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{8}
}
func (m *DoubleInputParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleInputParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleInputParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleInputParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleInputParamList.Merge(m, src)
}
func (m *DoubleInputParamList) XXX_Size() int {
	return m.Size()
}
func (m *DoubleInputParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleInputParamList.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleInputParamList proto.InternalMessageInfo

func (m *DoubleInputParamList) GetParams() []*DoubleInputParam {
	if m != nil {
		return m.Params
	}
	return nil
}

// DoubleWeightRange describes weight range that produce double value
type DoubleWeightRange struct {
	Lower  *FloatString `protobuf:"bytes,1,opt,name=Lower,proto3" json:"Lower,omitempty"`
	Upper  *FloatString `protobuf:"bytes,2,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Weight int64        `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *DoubleWeightRange) Reset()         { *m = DoubleWeightRange{} }
func (m *DoubleWeightRange) String() string { return proto.CompactTextString(m) }
func (*DoubleWeightRange) ProtoMessage()    {}
func (*DoubleWeightRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{9}
}
func (m *DoubleWeightRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleWeightRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleWeightRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleWeightRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleWeightRange.Merge(m, src)
}
func (m *DoubleWeightRange) XXX_Size() int {
	return m.Size()
}
func (m *DoubleWeightRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleWeightRange.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleWeightRange proto.InternalMessageInfo

func (m *DoubleWeightRange) GetLower() *FloatString {
	if m != nil {
		return m.Lower
	}
	return nil
}

func (m *DoubleWeightRange) GetUpper() *FloatString {
	if m != nil {
		return m.Upper
	}
	return nil
}

func (m *DoubleWeightRange) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type DoubleWeightTable struct {
	WeightRanges []*DoubleWeightRange `protobuf:"bytes,1,rep,name=WeightRanges,proto3" json:"WeightRanges,omitempty"`
}

func (m *DoubleWeightTable) Reset()         { *m = DoubleWeightTable{} }
func (m *DoubleWeightTable) String() string { return proto.CompactTextString(m) }
func (*DoubleWeightTable) ProtoMessage()    {}
func (*DoubleWeightTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{10}
}
func (m *DoubleWeightTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleWeightTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleWeightTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleWeightTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleWeightTable.Merge(m, src)
}
func (m *DoubleWeightTable) XXX_Size() int {
	return m.Size()
}
func (m *DoubleWeightTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleWeightTable.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleWeightTable proto.InternalMessageInfo

func (m *DoubleWeightTable) GetWeightRanges() []*DoubleWeightRange {
	if m != nil {
		return m.WeightRanges
	}
	return nil
}

// LongParam describes the bounds on an item input/output parameter of type int64
type LongParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate        *FloatString    `protobuf:"bytes,2,opt,name=Rate,proto3" json:"Rate,omitempty"`
	WeightTable *IntWeightTable `protobuf:"bytes,3,opt,name=WeightTable,proto3" json:"WeightTable,omitempty"`
	// When program is not empty, IntWeightTable is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *LongParam) Reset()         { *m = LongParam{} }
func (m *LongParam) String() string { return proto.CompactTextString(m) }
func (*LongParam) ProtoMessage()    {}
func (*LongParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{11}
}
func (m *LongParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongParam.Merge(m, src)
}
func (m *LongParam) XXX_Size() int {
	return m.Size()
}
func (m *LongParam) XXX_DiscardUnknown() {
	xxx_messageInfo_LongParam.DiscardUnknown(m)
}

var xxx_messageInfo_LongParam proto.InternalMessageInfo

func (m *LongParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongParam) GetRate() *FloatString {
	if m != nil {
		return m.Rate
	}
	return nil
}

func (m *LongParam) GetWeightTable() *IntWeightTable {
	if m != nil {
		return m.WeightTable
	}
	return nil
}

func (m *LongParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// LongParamList is a list of LongParam
type LongParamList struct {
	Params []*LongParam `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty"`
}

func (m *LongParamList) Reset()         { *m = LongParamList{} }
func (m *LongParamList) String() string { return proto.CompactTextString(m) }
func (*LongParamList) ProtoMessage()    {}
func (*LongParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{12}
}
func (m *LongParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongParamList.Merge(m, src)
}
func (m *LongParamList) XXX_Size() int {
	return m.Size()
}
func (m *LongParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_LongParamList.DiscardUnknown(m)
}

var xxx_messageInfo_LongParamList proto.InternalMessageInfo

func (m *LongParamList) GetParams() []*LongParam {
	if m != nil {
		return m.Params
	}
	return nil
}

// IntWeightRange describes weight range that produce int value
type IntWeightRange struct {
	Lower  int64 `protobuf:"varint,1,opt,name=Lower,proto3" json:"Lower,omitempty"`
	Upper  int64 `protobuf:"varint,2,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Weight int64 `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *IntWeightRange) Reset()         { *m = IntWeightRange{} }
func (m *IntWeightRange) String() string { return proto.CompactTextString(m) }
func (*IntWeightRange) ProtoMessage()    {}
func (*IntWeightRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{13}
}
func (m *IntWeightRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntWeightRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntWeightRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntWeightRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntWeightRange.Merge(m, src)
}
func (m *IntWeightRange) XXX_Size() int {
	return m.Size()
}
func (m *IntWeightRange) XXX_DiscardUnknown() {
	xxx_messageInfo_IntWeightRange.DiscardUnknown(m)
}

var xxx_messageInfo_IntWeightRange proto.InternalMessageInfo

func (m *IntWeightRange) GetLower() int64 {
	if m != nil {
		return m.Lower
	}
	return 0
}

func (m *IntWeightRange) GetUpper() int64 {
	if m != nil {
		return m.Upper
	}
	return 0
}

func (m *IntWeightRange) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// IntWeightTable describes weight loot table that produce int value
type IntWeightTable struct {
	WeightRanges []*IntWeightRange `protobuf:"bytes,1,rep,name=WeightRanges,proto3" json:"WeightRanges,omitempty"`
}

func (m *IntWeightTable) Reset()         { *m = IntWeightTable{} }
func (m *IntWeightTable) String() string { return proto.CompactTextString(m) }
func (*IntWeightTable) ProtoMessage()    {}
func (*IntWeightTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{14}
}
func (m *IntWeightTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntWeightTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntWeightTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntWeightTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntWeightTable.Merge(m, src)
}
func (m *IntWeightTable) XXX_Size() int {
	return m.Size()
}
func (m *IntWeightTable) XXX_DiscardUnknown() {
	xxx_messageInfo_IntWeightTable.DiscardUnknown(m)
}

var xxx_messageInfo_IntWeightTable proto.InternalMessageInfo

func (m *IntWeightTable) GetWeightRanges() []*IntWeightRange {
	if m != nil {
		return m.WeightRanges
	}
	return nil
}

// StringInputParam describes the bounds on an item input/output parameter of type string
type StringInputParam struct {
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// The value of the parameter
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *StringInputParam) Reset()         { *m = StringInputParam{} }
func (m *StringInputParam) String() string { return proto.CompactTextString(m) }
func (*StringInputParam) ProtoMessage()    {}
func (*StringInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{15}
}
func (m *StringInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringInputParam.Merge(m, src)
}
func (m *StringInputParam) XXX_Size() int {
	return m.Size()
}
func (m *StringInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_StringInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_StringInputParam proto.InternalMessageInfo

func (m *StringInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringInputParam) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// StringInputParamList is a list of StringInputParam
type StringInputParamList struct {
	List []*StringInputParam `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *StringInputParamList) Reset()         { *m = StringInputParamList{} }
func (m *StringInputParamList) String() string { return proto.CompactTextString(m) }
func (*StringInputParamList) ProtoMessage()    {}
func (*StringInputParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{16}
}
func (m *StringInputParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringInputParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringInputParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringInputParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringInputParamList.Merge(m, src)
}
func (m *StringInputParamList) XXX_Size() int {
	return m.Size()
}
func (m *StringInputParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_StringInputParamList.DiscardUnknown(m)
}

var xxx_messageInfo_StringInputParamList proto.InternalMessageInfo

func (m *StringInputParamList) GetList() []*StringInputParam {
	if m != nil {
		return m.List
	}
	return nil
}

type FeeInputParam struct {
	MinValue int64 `protobuf:"varint,1,opt,name=MinValue,proto3" json:"MinValue,omitempty"`
	MaxValue int64 `protobuf:"varint,2,opt,name=MaxValue,proto3" json:"MaxValue,omitempty"`
}

func (m *FeeInputParam) Reset()         { *m = FeeInputParam{} }
func (m *FeeInputParam) String() string { return proto.CompactTextString(m) }
func (*FeeInputParam) ProtoMessage()    {}
func (*FeeInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{17}
}
func (m *FeeInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeInputParam.Merge(m, src)
}
func (m *FeeInputParam) XXX_Size() int {
	return m.Size()
}
func (m *FeeInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_FeeInputParam proto.InternalMessageInfo

func (m *FeeInputParam) GetMinValue() int64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *FeeInputParam) GetMaxValue() int64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

// LongInputParam describes the bounds on an item input/output parameter of type int64
type LongInputParam struct {
	Key      string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	MinValue int64  `protobuf:"varint,2,opt,name=MinValue,proto3" json:"MinValue,omitempty"`
	MaxValue int64  `protobuf:"varint,3,opt,name=MaxValue,proto3" json:"MaxValue,omitempty"`
}

func (m *LongInputParam) Reset()         { *m = LongInputParam{} }
func (m *LongInputParam) String() string { return proto.CompactTextString(m) }
func (*LongInputParam) ProtoMessage()    {}
func (*LongInputParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{18}
}
func (m *LongInputParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongInputParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongInputParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongInputParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongInputParam.Merge(m, src)
}
func (m *LongInputParam) XXX_Size() int {
	return m.Size()
}
func (m *LongInputParam) XXX_DiscardUnknown() {
	xxx_messageInfo_LongInputParam.DiscardUnknown(m)
}

var xxx_messageInfo_LongInputParam proto.InternalMessageInfo

func (m *LongInputParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongInputParam) GetMinValue() int64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *LongInputParam) GetMaxValue() int64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

// LongInputParamList is a list of LongInputParam
type LongInputParamList struct {
	List []*LongInputParam `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *LongInputParamList) Reset()         { *m = LongInputParamList{} }
func (m *LongInputParamList) String() string { return proto.CompactTextString(m) }
func (*LongInputParamList) ProtoMessage()    {}
func (*LongInputParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{19}
}
func (m *LongInputParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongInputParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongInputParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongInputParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongInputParamList.Merge(m, src)
}
func (m *LongInputParamList) XXX_Size() int {
	return m.Size()
}
func (m *LongInputParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_LongInputParamList.DiscardUnknown(m)
}

var xxx_messageInfo_LongInputParamList proto.InternalMessageInfo

func (m *LongInputParamList) GetList() []*LongInputParam {
	if m != nil {
		return m.List
	}
	return nil
}

// ItemInput is a wrapper struct for Item for recipes
type ItemInput struct {
	ID          string                `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles     *DoubleInputParamList `protobuf:"bytes,2,opt,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs       *LongInputParamList   `protobuf:"bytes,3,opt,name=Longs,proto3" json:"Longs,omitempty"`
	Strings     *StringInputParamList `protobuf:"bytes,4,opt,name=Strings,proto3" json:"Strings,omitempty"`
	TransferFee *FeeInputParam        `protobuf:"bytes,5,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemInput) Reset()         { *m = ItemInput{} }
func (m *ItemInput) String() string { return proto.CompactTextString(m) }
func (*ItemInput) ProtoMessage()    {}
func (*ItemInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{20}
}
func (m *ItemInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemInput.Merge(m, src)
}
func (m *ItemInput) XXX_Size() int {
	return m.Size()
}
func (m *ItemInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemInput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemInput proto.InternalMessageInfo

func (m *ItemInput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemInput) GetDoubles() *DoubleInputParamList {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemInput) GetLongs() *LongInputParamList {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemInput) GetStrings() *StringInputParamList {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemInput) GetTransferFee() *FeeInputParam {
	if m != nil {
		return m.TransferFee
	}
	return nil
}

type ItemInputList struct {
	List []*ItemInput `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *ItemInputList) Reset()         { *m = ItemInputList{} }
func (m *ItemInputList) String() string { return proto.CompactTextString(m) }
func (*ItemInputList) ProtoMessage()    {}
func (*ItemInputList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{21}
}
func (m *ItemInputList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemInputList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemInputList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemInputList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemInputList.Merge(m, src)
}
func (m *ItemInputList) XXX_Size() int {
	return m.Size()
}
func (m *ItemInputList) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemInputList.DiscardUnknown(m)
}

var xxx_messageInfo_ItemInputList proto.InternalMessageInfo

func (m *ItemInputList) GetList() []*ItemInput {
	if m != nil {
		return m.List
	}
	return nil
}

// WeightedOutputs is to make structs which is using weight to be based on
type WeightedOutputs struct {
	EntryIDs []string `protobuf:"bytes,1,rep,name=EntryIDs,proto3" json:"EntryIDs,omitempty"`
	Weight   string   `protobuf:"bytes,2,opt,name=Weight,proto3" json:"Weight,omitempty"`
}

func (m *WeightedOutputs) Reset()         { *m = WeightedOutputs{} }
func (m *WeightedOutputs) String() string { return proto.CompactTextString(m) }
func (*WeightedOutputs) ProtoMessage()    {}
func (*WeightedOutputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{22}
}
func (m *WeightedOutputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedOutputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedOutputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedOutputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedOutputs.Merge(m, src)
}
func (m *WeightedOutputs) XXX_Size() int {
	return m.Size()
}
func (m *WeightedOutputs) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedOutputs.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedOutputs proto.InternalMessageInfo

func (m *WeightedOutputs) GetEntryIDs() []string {
	if m != nil {
		return m.EntryIDs
	}
	return nil
}

func (m *WeightedOutputs) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

// WeightedOutputsList is a struct to keep items which can be generated by weight;
// ItemOutput and CoinOutput is possible in current stage
type WeightedOutputsList struct {
	List []*WeightedOutputs `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *WeightedOutputsList) Reset()         { *m = WeightedOutputsList{} }
func (m *WeightedOutputsList) String() string { return proto.CompactTextString(m) }
func (*WeightedOutputsList) ProtoMessage()    {}
func (*WeightedOutputsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{23}
}
func (m *WeightedOutputsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedOutputsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedOutputsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedOutputsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedOutputsList.Merge(m, src)
}
func (m *WeightedOutputsList) XXX_Size() int {
	return m.Size()
}
func (m *WeightedOutputsList) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedOutputsList.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedOutputsList proto.InternalMessageInfo

func (m *WeightedOutputsList) GetList() []*WeightedOutputs {
	if m != nil {
		return m.List
	}
	return nil
}

// StringParam describes an item input/output parameter of type string
type StringParam struct {
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate  *FloatString `protobuf:"bytes,1,opt,name=Rate,proto3" json:"Rate,omitempty"`
	Key   string       `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string       `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
	// When program is not empty, Value is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *StringParam) Reset()         { *m = StringParam{} }
func (m *StringParam) String() string { return proto.CompactTextString(m) }
func (*StringParam) ProtoMessage()    {}
func (*StringParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{24}
}
func (m *StringParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringParam.Merge(m, src)
}
func (m *StringParam) XXX_Size() int {
	return m.Size()
}
func (m *StringParam) XXX_DiscardUnknown() {
	xxx_messageInfo_StringParam.DiscardUnknown(m)
}

var xxx_messageInfo_StringParam proto.InternalMessageInfo

func (m *StringParam) GetRate() *FloatString {
	if m != nil {
		return m.Rate
	}
	return nil
}

func (m *StringParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringParam) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StringParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// StringParamList is a list of StringParam
type StringParamList struct {
	List []*StringParam `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *StringParamList) Reset()         { *m = StringParamList{} }
func (m *StringParamList) String() string { return proto.CompactTextString(m) }
func (*StringParamList) ProtoMessage()    {}
func (*StringParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{25}
}
func (m *StringParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringParamList.Merge(m, src)
}
func (m *StringParamList) XXX_Size() int {
	return m.Size()
}
func (m *StringParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_StringParamList.DiscardUnknown(m)
}

var xxx_messageInfo_StringParamList proto.InternalMessageInfo

func (m *StringParamList) GetList() []*StringParam {
	if m != nil {
		return m.List
	}
	return nil
}

// DoubleParam describes the bounds on an item input/output parameter of type float64
type DoubleParam struct {
	// The likelihood that this parameter is applied to the output item. Between 0.0 (exclusive) and 1.0 (inclusive).
	Rate        *FloatString       `protobuf:"bytes,1,opt,name=Rate,proto3" json:"Rate,omitempty"`
	Key         string             `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	WeightTable *DoubleWeightTable `protobuf:"bytes,3,opt,name=WeightTable,proto3" json:"WeightTable,omitempty"`
	// When program is not empty, DoubleWeightTable is ignored
	Program string `protobuf:"bytes,4,opt,name=Program,proto3" json:"Program,omitempty"`
}

func (m *DoubleParam) Reset()         { *m = DoubleParam{} }
func (m *DoubleParam) String() string { return proto.CompactTextString(m) }
func (*DoubleParam) ProtoMessage()    {}
func (*DoubleParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{26}
}
func (m *DoubleParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleParam.Merge(m, src)
}
func (m *DoubleParam) XXX_Size() int {
	return m.Size()
}
func (m *DoubleParam) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleParam.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleParam proto.InternalMessageInfo

func (m *DoubleParam) GetRate() *FloatString {
	if m != nil {
		return m.Rate
	}
	return nil
}

func (m *DoubleParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DoubleParam) GetWeightTable() *DoubleWeightTable {
	if m != nil {
		return m.WeightTable
	}
	return nil
}

func (m *DoubleParam) GetProgram() string {
	if m != nil {
		return m.Program
	}
	return ""
}

// DoubleParamList is a list of DoubleParam
type DoubleParamList struct {
	List []*DoubleParam `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *DoubleParamList) Reset()         { *m = DoubleParamList{} }
func (m *DoubleParamList) String() string { return proto.CompactTextString(m) }
func (*DoubleParamList) ProtoMessage()    {}
func (*DoubleParamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{27}
}
func (m *DoubleParamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleParamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleParamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleParamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleParamList.Merge(m, src)
}
func (m *DoubleParamList) XXX_Size() int {
	return m.Size()
}
func (m *DoubleParamList) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleParamList.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleParamList proto.InternalMessageInfo

func (m *DoubleParamList) GetList() []*DoubleParam {
	if m != nil {
		return m.List
	}
	return nil
}

// ItemOutput models the continuum of valid outcomes for item generation in recipes
type ItemOutput struct {
	ID          string           `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles     *DoubleParamList `protobuf:"bytes,2,opt,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs       *LongParamList   `protobuf:"bytes,3,opt,name=Longs,proto3" json:"Longs,omitempty"`
	Strings     *StringParamList `protobuf:"bytes,4,opt,name=Strings,proto3" json:"Strings,omitempty"`
	TransferFee int64            `protobuf:"varint,5,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemOutput) Reset()         { *m = ItemOutput{} }
func (m *ItemOutput) String() string { return proto.CompactTextString(m) }
func (*ItemOutput) ProtoMessage()    {}
func (*ItemOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{28}
}
func (m *ItemOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemOutput.Merge(m, src)
}
func (m *ItemOutput) XXX_Size() int {
	return m.Size()
}
func (m *ItemOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemOutput proto.InternalMessageInfo

func (m *ItemOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemOutput) GetDoubles() *DoubleParamList {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemOutput) GetLongs() *LongParamList {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemOutput) GetStrings() *StringParamList {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemOutput) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// ItemModifyOutput describes what is modified from item input
type ItemModifyOutput struct {
	ID           string           `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ItemInputRef string           `protobuf:"bytes,2,opt,name=ItemInputRef,proto3" json:"ItemInputRef,omitempty"`
	Doubles      *DoubleParamList `protobuf:"bytes,3,opt,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs        *LongParamList   `protobuf:"bytes,4,opt,name=Longs,proto3" json:"Longs,omitempty"`
	Strings      *StringParamList `protobuf:"bytes,5,opt,name=Strings,proto3" json:"Strings,omitempty"`
	TransferFee  int64            `protobuf:"varint,6,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemModifyOutput) Reset()         { *m = ItemModifyOutput{} }
func (m *ItemModifyOutput) String() string { return proto.CompactTextString(m) }
func (*ItemModifyOutput) ProtoMessage()    {}
func (*ItemModifyOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{29}
}
func (m *ItemModifyOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemModifyOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemModifyOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemModifyOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemModifyOutput.Merge(m, src)
}
func (m *ItemModifyOutput) XXX_Size() int {
	return m.Size()
}
func (m *ItemModifyOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemModifyOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ItemModifyOutput proto.InternalMessageInfo

func (m *ItemModifyOutput) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ItemModifyOutput) GetItemInputRef() string {
	if m != nil {
		return m.ItemInputRef
	}
	return ""
}

func (m *ItemModifyOutput) GetDoubles() *DoubleParamList {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemModifyOutput) GetLongs() *LongParamList {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemModifyOutput) GetStrings() *StringParamList {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemModifyOutput) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// ItemModifyParams describes the fields that needs to be modified
type ItemModifyParams struct {
	Doubles     *DoubleParamList `protobuf:"bytes,1,opt,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs       *LongParamList   `protobuf:"bytes,2,opt,name=Longs,proto3" json:"Longs,omitempty"`
	Strings     *StringParamList `protobuf:"bytes,3,opt,name=Strings,proto3" json:"Strings,omitempty"`
	TransferFee int64            `protobuf:"varint,4,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *ItemModifyParams) Reset()         { *m = ItemModifyParams{} }
func (m *ItemModifyParams) String() string { return proto.CompactTextString(m) }
func (*ItemModifyParams) ProtoMessage()    {}
func (*ItemModifyParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{30}
}
func (m *ItemModifyParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemModifyParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemModifyParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemModifyParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemModifyParams.Merge(m, src)
}
func (m *ItemModifyParams) XXX_Size() int {
	return m.Size()
}
func (m *ItemModifyParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemModifyParams.DiscardUnknown(m)
}

var xxx_messageInfo_ItemModifyParams proto.InternalMessageInfo

func (m *ItemModifyParams) GetDoubles() *DoubleParamList {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *ItemModifyParams) GetLongs() *LongParamList {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *ItemModifyParams) GetStrings() *StringParamList {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ItemModifyParams) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// Item is a tradable asset
type Item struct {
	NodeVersion   *SemVer           `protobuf:"bytes,1,opt,name=NodeVersion,proto3" json:"NodeVersion,omitempty"`
	ID            string            `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Doubles       []*DoubleKeyValue `protobuf:"bytes,3,rep,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs         []*LongKeyValue   `protobuf:"bytes,4,rep,name=Longs,proto3" json:"Longs,omitempty"`
	Strings       []*StringKeyValue `protobuf:"bytes,5,rep,name=Strings,proto3" json:"Strings,omitempty"`
	CookbookID    string            `protobuf:"bytes,6,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Sender        string            `protobuf:"bytes,7,opt,name=Sender,proto3" json:"Sender,omitempty"`
	OwnerRecipeID string            `protobuf:"bytes,8,opt,name=OwnerRecipeID,proto3" json:"OwnerRecipeID,omitempty"`
	OwnerTradeID  string            `protobuf:"bytes,9,opt,name=OwnerTradeID,proto3" json:"OwnerTradeID,omitempty"`
	Tradable      bool              `protobuf:"varint,10,opt,name=Tradable,proto3" json:"Tradable,omitempty"`
	LastUpdate    int64             `protobuf:"varint,11,opt,name=LastUpdate,proto3" json:"LastUpdate,omitempty"`
	TransferFee   int64             `protobuf:"varint,12,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{31}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetNodeVersion() *SemVer {
	if m != nil {
		return m.NodeVersion
	}
	return nil
}

func (m *Item) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Item) GetDoubles() []*DoubleKeyValue {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *Item) GetLongs() []*LongKeyValue {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *Item) GetStrings() []*StringKeyValue {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Item) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *Item) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Item) GetOwnerRecipeID() string {
	if m != nil {
		return m.OwnerRecipeID
	}
	return ""
}

func (m *Item) GetOwnerTradeID() string {
	if m != nil {
		return m.OwnerTradeID
	}
	return ""
}

func (m *Item) GetTradable() bool {
	if m != nil {
		return m.Tradable
	}
	return false
}

func (m *Item) GetLastUpdate() int64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Item) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// ItemList is a list of items
type ItemList struct {
	List []*Item `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *ItemList) Reset()         { *m = ItemList{} }
func (m *ItemList) String() string { return proto.CompactTextString(m) }
func (*ItemList) ProtoMessage()    {}
func (*ItemList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{32}
}
func (m *ItemList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemList.Merge(m, src)
}
func (m *ItemList) XXX_Size() int {
	return m.Size()
}
func (m *ItemList) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemList.DiscardUnknown(m)
}

var xxx_messageInfo_ItemList proto.InternalMessageInfo

func (m *ItemList) GetList() []*Item {
	if m != nil {
		return m.List
	}
	return nil
}

// DoubleKeyValue describes double key/value set
type DoubleKeyValue struct {
	Key   string       `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value *FloatString `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *DoubleKeyValue) Reset()         { *m = DoubleKeyValue{} }
func (m *DoubleKeyValue) String() string { return proto.CompactTextString(m) }
func (*DoubleKeyValue) ProtoMessage()    {}
func (*DoubleKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{33}
}
func (m *DoubleKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleKeyValue.Merge(m, src)
}
func (m *DoubleKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *DoubleKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleKeyValue proto.InternalMessageInfo

func (m *DoubleKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DoubleKeyValue) GetValue() *FloatString {
	if m != nil {
		return m.Value
	}
	return nil
}

// LongKeyValue describes long key/value set
type LongKeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LongKeyValue) Reset()         { *m = LongKeyValue{} }
func (m *LongKeyValue) String() string { return proto.CompactTextString(m) }
func (*LongKeyValue) ProtoMessage()    {}
func (*LongKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{34}
}
func (m *LongKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongKeyValue.Merge(m, src)
}
func (m *LongKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *LongKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LongKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_LongKeyValue proto.InternalMessageInfo

func (m *LongKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LongKeyValue) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// StringKeyValue describes string key/value set
type StringKeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *StringKeyValue) Reset()         { *m = StringKeyValue{} }
func (m *StringKeyValue) String() string { return proto.CompactTextString(m) }
func (*StringKeyValue) ProtoMessage()    {}
func (*StringKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{35}
}
func (m *StringKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringKeyValue.Merge(m, src)
}
func (m *StringKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *StringKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_StringKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_StringKeyValue proto.InternalMessageInfo

func (m *StringKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringKeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TradeItemInput is a wrapper struct for Item for trades
type TradeItemInput struct {
	ItemInput  *ItemInput `protobuf:"bytes,1,opt,name=ItemInput,proto3" json:"ItemInput,omitempty"`
	CookbookID string     `protobuf:"bytes,2,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
}

func (m *TradeItemInput) Reset()         { *m = TradeItemInput{} }
func (m *TradeItemInput) String() string { return proto.CompactTextString(m) }
func (*TradeItemInput) ProtoMessage()    {}
func (*TradeItemInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{36}
}
func (m *TradeItemInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeItemInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeItemInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeItemInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeItemInput.Merge(m, src)
}
func (m *TradeItemInput) XXX_Size() int {
	return m.Size()
}
func (m *TradeItemInput) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeItemInput.DiscardUnknown(m)
}

var xxx_messageInfo_TradeItemInput proto.InternalMessageInfo

func (m *TradeItemInput) GetItemInput() *ItemInput {
	if m != nil {
		return m.ItemInput
	}
	return nil
}

func (m *TradeItemInput) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

// TradeItemInputList is a list of ItemInputs for convinience
type TradeItemInputList struct {
	List []*TradeItemInput `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *TradeItemInputList) Reset()         { *m = TradeItemInputList{} }
func (m *TradeItemInputList) String() string { return proto.CompactTextString(m) }
func (*TradeItemInputList) ProtoMessage()    {}
func (*TradeItemInputList) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbe4a0dc0744f938, []int{37}
}
func (m *TradeItemInputList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeItemInputList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeItemInputList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeItemInputList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeItemInputList.Merge(m, src)
}
func (m *TradeItemInputList) XXX_Size() int {
	return m.Size()
}
func (m *TradeItemInputList) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeItemInputList.DiscardUnknown(m)
}

var xxx_messageInfo_TradeItemInputList proto.InternalMessageInfo

func (m *TradeItemInputList) GetList() []*TradeItemInput {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*CoinInputList)(nil), "pylons.CoinInputList")
	proto.RegisterType((*CoinInput)(nil), "pylons.CoinInput")
	proto.RegisterType((*CoinOutput)(nil), "pylons.CoinOutput")
	proto.RegisterType((*SemVer)(nil), "pylons.SemVer")
	proto.RegisterType((*Level)(nil), "pylons.Level")
	proto.RegisterType((*Email)(nil), "pylons.Email")
	proto.RegisterType((*FloatString)(nil), "pylons.FloatString")
	proto.RegisterType((*DoubleInputParam)(nil), "pylons.DoubleInputParam")
	proto.RegisterType((*DoubleInputParamList)(nil), "pylons.DoubleInputParamList")
	proto.RegisterType((*DoubleWeightRange)(nil), "pylons.DoubleWeightRange")
	proto.RegisterType((*DoubleWeightTable)(nil), "pylons.DoubleWeightTable")
	proto.RegisterType((*LongParam)(nil), "pylons.LongParam")
	proto.RegisterType((*LongParamList)(nil), "pylons.LongParamList")
	proto.RegisterType((*IntWeightRange)(nil), "pylons.IntWeightRange")
	proto.RegisterType((*IntWeightTable)(nil), "pylons.IntWeightTable")
	proto.RegisterType((*StringInputParam)(nil), "pylons.StringInputParam")
	proto.RegisterType((*StringInputParamList)(nil), "pylons.StringInputParamList")
	proto.RegisterType((*FeeInputParam)(nil), "pylons.FeeInputParam")
	proto.RegisterType((*LongInputParam)(nil), "pylons.LongInputParam")
	proto.RegisterType((*LongInputParamList)(nil), "pylons.LongInputParamList")
	proto.RegisterType((*ItemInput)(nil), "pylons.ItemInput")
	proto.RegisterType((*ItemInputList)(nil), "pylons.ItemInputList")
	proto.RegisterType((*WeightedOutputs)(nil), "pylons.WeightedOutputs")
	proto.RegisterType((*WeightedOutputsList)(nil), "pylons.WeightedOutputsList")
	proto.RegisterType((*StringParam)(nil), "pylons.StringParam")
	proto.RegisterType((*StringParamList)(nil), "pylons.StringParamList")
	proto.RegisterType((*DoubleParam)(nil), "pylons.DoubleParam")
	proto.RegisterType((*DoubleParamList)(nil), "pylons.DoubleParamList")
	proto.RegisterType((*ItemOutput)(nil), "pylons.ItemOutput")
	proto.RegisterType((*ItemModifyOutput)(nil), "pylons.ItemModifyOutput")
	proto.RegisterType((*ItemModifyParams)(nil), "pylons.ItemModifyParams")
	proto.RegisterType((*Item)(nil), "pylons.Item")
	proto.RegisterType((*ItemList)(nil), "pylons.ItemList")
	proto.RegisterType((*DoubleKeyValue)(nil), "pylons.DoubleKeyValue")
	proto.RegisterType((*LongKeyValue)(nil), "pylons.LongKeyValue")
	proto.RegisterType((*StringKeyValue)(nil), "pylons.StringKeyValue")
	proto.RegisterType((*TradeItemInput)(nil), "pylons.TradeItemInput")
	proto.RegisterType((*TradeItemInputList)(nil), "pylons.TradeItemInputList")
}

func init() { proto.RegisterFile("pylons/query.proto", fileDescriptor_dbe4a0dc0744f938) }

var fileDescriptor_dbe4a0dc0744f938 = []byte{
	// 1262 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcf, 0x4f, 0x1b, 0xc7,
	0x17, 0x67, 0xbd, 0xb6, 0xc1, 0xcf, 0xd8, 0x90, 0xc5, 0x01, 0x63, 0x45, 0x8e, 0xb5, 0xfa, 0x7e,
	0x15, 0x48, 0x28, 0x26, 0x54, 0xa5, 0x88, 0xaa, 0x52, 0x95, 0x18, 0x5a, 0x0b, 0xd3, 0xa0, 0x85,
	0x50, 0x29, 0xb7, 0x35, 0x1e, 0x96, 0x55, 0xec, 0x19, 0x77, 0x77, 0xdd, 0xe0, 0x63, 0x2f, 0x3d,
	0xf7, 0xdc, 0x4b, 0xff, 0x8d, 0xfe, 0x07, 0xed, 0x31, 0xbd, 0xf5, 0x58, 0xc1, 0xff, 0xd0, 0x4b,
	0x2f, 0xd5, 0xfc, 0xd8, 0xf5, 0xcc, 0x7a, 0x6d, 0xea, 0xf4, 0xe4, 0x9d, 0x99, 0xcf, 0xbc, 0x79,
	0x9f, 0xf9, 0xbc, 0xf7, 0xe6, 0x19, 0x8c, 0xfe, 0xb0, 0x4b, 0xb0, 0x5f, 0xff, 0x76, 0x80, 0xbc,
	0xe1, 0x76, 0xdf, 0x23, 0x01, 0x31, 0xb2, 0x7c, 0xae, 0x52, 0x72, 0x88, 0x43, 0xd8, 0x54, 0x9d,
	0x7e, 0xf1, 0xd5, 0xca, 0xba, 0x43, 0x88, 0xd3, 0x45, 0x75, 0x36, 0x6a, 0x0f, 0xae, 0xea, 0x36,
	0x16, 0x1b, 0x2b, 0x8f, 0xc4, 0x92, 0xdd, 0x77, 0xeb, 0x36, 0xc6, 0x24, 0xb0, 0x03, 0x97, 0x60,
	0x9f, 0xaf, 0x9a, 0xfb, 0x50, 0x78, 0x49, 0x5c, 0xdc, 0xc4, 0xfd, 0x41, 0xd0, 0x72, 0xfd, 0xc0,
	0x78, 0x02, 0x99, 0x4b, 0xe2, 0x62, 0xbf, 0xac, 0xd5, 0xf4, 0x8d, 0xfc, 0xee, 0x83, 0x6d, 0x7e,
	0xee, 0x76, 0x84, 0xb2, 0xf8, 0xba, 0xf9, 0x09, 0xe4, 0xa2, 0x39, 0xc3, 0x80, 0x34, 0x1d, 0x94,
	0xb5, 0x9a, 0xb6, 0x91, 0xb3, 0xd8, 0xb7, 0x51, 0x82, 0xcc, 0x4b, 0x32, 0xc0, 0x41, 0x39, 0x55,
	0xd3, 0x36, 0x74, 0x8b, 0x0f, 0xcc, 0x23, 0x00, 0xba, 0xfa, 0x6a, 0x10, 0xd0, 0x7d, 0x45, 0x48,
	0x35, 0x1b, 0x62, 0x57, 0xaa, 0xd9, 0x88, 0xec, 0xa4, 0x92, 0xec, 0xe8, 0x6c, 0x52, 0xd8, 0xa9,
	0x41, 0xf6, 0x0c, 0xf5, 0x2e, 0x90, 0x67, 0xac, 0x42, 0x16, 0x0f, 0x7a, 0x6d, 0xe4, 0x09, 0x3b,
	0x62, 0x64, 0x3e, 0x86, 0x4c, 0x0b, 0x7d, 0x87, 0xba, 0x31, 0x80, 0x1e, 0x01, 0xd6, 0x21, 0x73,
	0xd8, 0xb3, 0xdd, 0xae, 0xb1, 0x0c, 0xba, 0x1f, 0x84, 0xdb, 0xe9, 0xa7, 0xf9, 0x18, 0xf2, 0x47,
	0x5d, 0x62, 0x07, 0x67, 0x81, 0xe7, 0x62, 0x27, 0x01, 0xf0, 0x83, 0x06, 0xcb, 0x0d, 0x32, 0x68,
	0x77, 0x11, 0xbb, 0x80, 0x53, 0xdb, 0xb3, 0x7b, 0x14, 0x76, 0x8c, 0x86, 0x21, 0xec, 0x18, 0x0d,
	0x8d, 0x3a, 0x2c, 0x9c, 0xb8, 0xf8, 0xc2, 0xee, 0x0e, 0x10, 0xe3, 0x94, 0xdf, 0x5d, 0x09, 0x2f,
	0x54, 0xb2, 0x6f, 0x45, 0x20, 0xb6, 0xc1, 0xbe, 0xe1, 0x1b, 0xf4, 0x69, 0x1b, 0x04, 0xc8, 0xfc,
	0x0a, 0x4a, 0x71, 0x3f, 0x98, 0x8e, 0x3b, 0x90, 0xed, 0xd3, 0x41, 0x28, 0x64, 0x39, 0x34, 0x13,
	0x47, 0x5b, 0x02, 0x67, 0x7e, 0xaf, 0xc1, 0x03, 0xbe, 0xf8, 0x0d, 0x72, 0x9d, 0xeb, 0xc0, 0xb2,
	0xb1, 0x83, 0x8c, 0x4d, 0xc8, 0xb4, 0xc8, 0x3b, 0x71, 0x77, 0x13, 0xbc, 0xe1, 0x08, 0x0a, 0x7d,
	0xdd, 0xef, 0x23, 0x6f, 0x1a, 0x53, 0x8e, 0xa0, 0x92, 0xf0, 0x43, 0x18, 0x49, 0xdd, 0x12, 0x23,
	0xd3, 0x52, 0x5d, 0x38, 0xb7, 0xdb, 0x5d, 0x64, 0x7c, 0x0e, 0x8b, 0x92, 0x47, 0x21, 0xa1, 0x75,
	0x95, 0x90, 0x84, 0xb0, 0x14, 0xb8, 0xf9, 0x93, 0x06, 0xb9, 0x16, 0xc1, 0xce, 0x24, 0x8d, 0x9e,
	0x40, 0xda, 0xb2, 0x83, 0xa9, 0xfa, 0x30, 0x80, 0xb1, 0x0f, 0x79, 0xc9, 0x2d, 0x21, 0xcf, 0x6a,
	0x88, 0x6f, 0xe2, 0x40, 0x5a, 0xb5, 0x64, 0xa8, 0x51, 0x86, 0xf9, 0x53, 0x8f, 0x38, 0x9e, 0xdd,
	0x2b, 0xa7, 0xd9, 0xc1, 0xe1, 0xd0, 0x3c, 0x80, 0x42, 0xe4, 0x1b, 0xd3, 0x6d, 0x33, 0xa6, 0x5b,
	0x94, 0x80, 0x11, 0x2c, 0x12, 0xec, 0x1c, 0x8a, 0xd1, 0xa1, 0x5c, 0xac, 0x92, 0x2c, 0x96, 0x1e,
	0xea, 0x52, 0x92, 0x75, 0xd1, 0xef, 0x93, 0xa0, 0x25, 0x59, 0xe5, 0xde, 0x1f, 0x24, 0xde, 0xff,
	0x38, 0xf1, 0xa4, 0xcb, 0x3f, 0x80, 0x65, 0x7e, 0x87, 0x53, 0xd3, 0xa4, 0x04, 0x99, 0x51, 0x8e,
	0xe4, 0x2c, 0x3e, 0x30, 0x1b, 0x50, 0x8a, 0xef, 0x65, 0x57, 0xb4, 0x05, 0x69, 0xfa, 0x1b, 0x0f,
	0xec, 0x38, 0xd6, 0x62, 0x28, 0xf3, 0x4b, 0x28, 0x1c, 0x21, 0x39, 0x4b, 0x2b, 0x52, 0x4e, 0xf2,
	0x7b, 0x1a, 0xa5, 0x5f, 0x45, 0x4a, 0xbf, 0x94, 0x58, 0x0b, 0x33, 0xed, 0x0d, 0x14, 0xa9, 0x06,
	0x53, 0x89, 0x54, 0x62, 0xf9, 0x3e, 0xc9, 0xb6, 0x1e, 0xb3, 0xfd, 0x05, 0x18, 0xaa, 0x6d, 0x46,
	0xf4, 0xa9, 0x42, 0x74, 0x55, 0x8e, 0x84, 0x31, 0x9a, 0x7f, 0x69, 0x90, 0x6b, 0x06, 0xa8, 0xc7,
	0xeb, 0x71, 0xbc, 0xae, 0xee, 0xc1, 0x3c, 0x4f, 0x13, 0x5f, 0x84, 0xf9, 0xa3, 0x49, 0xe5, 0x80,
	0x1a, 0xb3, 0x42, 0xb0, 0xb1, 0x43, 0x03, 0x0a, 0x3b, 0xbe, 0x08, 0xf6, 0x4a, 0xb2, 0x0b, 0x6c,
	0x0f, 0x07, 0xd2, 0x93, 0xb8, 0x10, 0x3e, 0x0b, 0x75, 0xe9, 0xa4, 0x24, 0x2d, 0xad, 0x10, 0x6c,
	0x7c, 0x0a, 0xf9, 0x73, 0xcf, 0xc6, 0xfe, 0x15, 0xf2, 0x8e, 0x10, 0x2a, 0x67, 0xd8, 0xde, 0x87,
	0x51, 0x32, 0xca, 0x0a, 0x5a, 0x32, 0xd2, 0xdc, 0x83, 0x42, 0xc4, 0x9b, 0xdd, 0xda, 0xff, 0x95,
	0x5b, 0x8b, 0xf2, 0x27, 0x02, 0x89, 0x0b, 0x3b, 0x84, 0x25, 0x1e, 0xa9, 0xa8, 0xc3, 0x1f, 0x23,
	0x9f, 0x2a, 0x74, 0x88, 0x03, 0x6f, 0xd8, 0x6c, 0xf0, 0x20, 0xcf, 0x59, 0xd1, 0x58, 0x4a, 0x17,
	0x1e, 0xa3, 0x61, 0xba, 0xbc, 0x80, 0x95, 0x98, 0x19, 0xe6, 0xc4, 0x33, 0xc5, 0x89, 0xb5, 0xd0,
	0x89, 0x18, 0x54, 0xb8, 0x72, 0x03, 0x79, 0x7e, 0x0d, 0x3c, 0xac, 0xc2, 0x82, 0xa4, 0xdd, 0x57,
	0x90, 0x44, 0xfc, 0xa5, 0x12, 0x12, 0x49, 0x97, 0x12, 0x69, 0x6a, 0xf9, 0x59, 0x92, 0x4e, 0x16,
	0x0d, 0x80, 0xec, 0xf9, 0x8a, 0xaa, 0x9e, 0x1c, 0x71, 0x3f, 0x6b, 0x90, 0xe7, 0x71, 0xf2, 0x9f,
	0xdd, 0xfe, 0x2c, 0xa9, 0xb2, 0x26, 0x16, 0xf8, 0x19, 0x8b, 0xeb, 0x92, 0xe4, 0xe0, 0x34, 0x76,
	0x12, 0x4c, 0xb0, 0xfb, 0x5d, 0x03, 0xa0, 0x21, 0x33, 0xa1, 0x51, 0x79, 0x1e, 0x4f, 0xa8, 0xb5,
	0x04, 0x53, 0x6a, 0x2e, 0x3d, 0x53, 0x73, 0xe9, 0xe1, 0x58, 0x61, 0x97, 0xd3, 0xe8, 0x79, 0x3c,
	0x8d, 0xd6, 0x12, 0x84, 0x50, 0x33, 0xa8, 0x36, 0x9e, 0x41, 0xba, 0x9a, 0x2a, 0x7f, 0x6b, 0xb0,
	0x4c, 0x39, 0x9d, 0x90, 0x8e, 0x7b, 0x35, 0x9c, 0xc0, 0xcc, 0x84, 0xc5, 0x51, 0xaa, 0xa0, 0x2b,
	0x21, 0x93, 0x32, 0x27, 0xb3, 0xd7, 0x67, 0x65, 0x9f, 0x9e, 0x8d, 0x7d, 0xe6, 0xc3, 0xd8, 0x67,
	0xc7, 0xd9, 0xff, 0xaa, 0xb0, 0x67, 0x26, 0x7c, 0x99, 0x89, 0x36, 0x2b, 0x93, 0xd4, 0x6c, 0x4c,
	0xf4, 0x0f, 0x63, 0x92, 0x1e, 0x67, 0xf2, 0x8b, 0x0e, 0x69, 0xca, 0xc4, 0xd8, 0x81, 0xfc, 0xd7,
	0xa4, 0x83, 0x2e, 0x90, 0xe7, 0xbb, 0x04, 0x0b, 0x06, 0xc5, 0xe8, 0x04, 0xd6, 0x1f, 0x5b, 0x32,
	0x44, 0xa8, 0x9d, 0x8a, 0xd4, 0xde, 0x91, 0x95, 0x54, 0x5e, 0x19, 0x3e, 0x7d, 0x8c, 0x86, 0xac,
	0x86, 0x8c, 0xe8, 0x3f, 0x1d, 0x09, 0x49, 0xf1, 0x25, 0x99, 0x7e, 0x84, 0x16, 0xec, 0x77, 0x64,
	0x1d, 0x15, 0xeb, 0x7c, 0x7a, 0x64, 0x3d, 0x24, 0x5f, 0xa5, 0x7f, 0x0f, 0xc8, 0xdb, 0x36, 0x21,
	0x6f, 0x9b, 0x0d, 0xa6, 0x62, 0xce, 0x92, 0x66, 0x68, 0x19, 0x3e, 0x43, 0xb8, 0x83, 0xbc, 0xf2,
	0x3c, 0x2f, 0xc3, 0x7c, 0x64, 0xfc, 0x0f, 0x0a, 0xaf, 0xde, 0x61, 0xe4, 0x59, 0xe8, 0xd2, 0xed,
	0xa3, 0x66, 0xa3, 0xbc, 0xc0, 0x96, 0xd5, 0x49, 0x1a, 0xdb, 0x6c, 0xe2, 0xdc, 0xb3, 0x3b, 0x14,
	0x94, 0xe3, 0xb1, 0x2d, 0xcf, 0xd1, 0x47, 0x80, 0x7e, 0xb2, 0x42, 0x04, 0x35, 0x6d, 0x63, 0xc1,
	0x8a, 0xc6, 0xd4, 0xbb, 0x96, 0xed, 0x07, 0xaf, 0xfb, 0x1d, 0x5a, 0xe8, 0xf2, 0x4c, 0x19, 0x69,
	0x26, 0x2e, 0xdd, 0xe2, 0xb8, 0x74, 0x5b, 0xb0, 0x40, 0x95, 0x63, 0xb5, 0xa8, 0xa6, 0xd4, 0xa2,
	0x45, 0xf9, 0xa1, 0x12, 0x45, 0xe8, 0x04, 0x8a, 0xaa, 0x0c, 0x09, 0x2d, 0xc7, 0xa6, 0xdc, 0x3b,
	0x4d, 0xea, 0xba, 0x79, 0x97, 0xb1, 0x07, 0x8b, 0xb2, 0x4a, 0xf7, 0x35, 0x62, 0x7a, 0xb8, 0x6f,
	0x1f, 0x8a, 0xaa, 0x5e, 0xff, 0xba, 0x85, 0xb3, 0xa1, 0xc8, 0xef, 0x35, 0xea, 0x4c, 0xea, 0x52,
	0x9b, 0x22, 0x02, 0x36, 0xe1, 0x89, 0x96, 0x5a, 0x19, 0x35, 0x22, 0x52, 0xf1, 0x88, 0xa0, 0xad,
	0x93, 0x7a, 0xc4, 0xb4, 0xd6, 0x49, 0x45, 0xf2, 0x5b, 0xde, 0x2d, 0x40, 0x9e, 0x3e, 0xf3, 0x2e,
	0x62, 0x4f, 0xf7, 0x8b, 0xa3, 0xdf, 0x6e, 0xab, 0xda, 0xfb, 0xdb, 0xaa, 0xf6, 0xe7, 0x6d, 0x55,
	0xfb, 0xf1, 0xae, 0x3a, 0xf7, 0xfe, 0xae, 0x3a, 0xf7, 0xc7, 0x5d, 0x75, 0xee, 0xcd, 0x96, 0xe3,
	0x06, 0xd7, 0x83, 0xf6, 0xf6, 0x25, 0xe9, 0xd5, 0x4f, 0x99, 0xc1, 0x8f, 0x02, 0x74, 0x79, 0x5d,
	0x17, 0x7f, 0xd7, 0x6f, 0xc2, 0x8f, 0x60, 0xd8, 0x47, 0x7e, 0x3b, 0xcb, 0xfe, 0x61, 0x7f, 0xfc,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0x21, 0xdb, 0x2f, 0xce, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EntriesListClient is the client API for EntriesList service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EntriesListClient interface {
}

type entriesListClient struct {
	cc grpc1.ClientConn
}

func NewEntriesListClient(cc grpc1.ClientConn) EntriesListClient {
	return &entriesListClient{cc}
}

// EntriesListServer is the server API for EntriesList service.
type EntriesListServer interface {
}

// UnimplementedEntriesListServer can be embedded to have forward compatible implementations.
type UnimplementedEntriesListServer struct {
}

func RegisterEntriesListServer(s grpc1.Server, srv EntriesListServer) {
	s.RegisterService(&_EntriesList_serviceDesc, srv)
}

var _EntriesList_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pylons.EntriesList",
	HandlerType: (*EntriesListServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "pylons/query.proto",
}

func (m *CoinInputList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinInputList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinInputList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CoinInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CoinOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Count) > 0 {
		i -= len(m.Count)
		copy(dAtA[i:], m.Count)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Count)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Coin) > 0 {
		i -= len(m.Coin)
		copy(dAtA[i:], m.Coin)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Coin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemVer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemVer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Number) > 0 {
		i -= len(m.Number)
		copy(dAtA[i:], m.Number)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Number)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Level) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Level) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Level) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Email) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Email) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Email) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Str) > 0 {
		i -= len(m.Str)
		copy(dAtA[i:], m.Str)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Str)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FloatString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Str) > 0 {
		i -= len(m.Str)
		copy(dAtA[i:], m.Str)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Str)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != nil {
		{
			size, err := m.MaxValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MinValue != nil {
		{
			size, err := m.MinValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleInputParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleInputParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleInputParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DoubleWeightRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleWeightRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleWeightRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Upper != nil {
		{
			size, err := m.Upper.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Lower != nil {
		{
			size, err := m.Lower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleWeightTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleWeightTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleWeightTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for iNdEx := len(m.WeightRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeightRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LongParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	if m.WeightTable != nil {
		{
			size, err := m.WeightTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Rate != nil {
		{
			size, err := m.Rate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LongParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IntWeightRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntWeightRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntWeightRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Upper != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Upper))
		i--
		dAtA[i] = 0x10
	}
	if m.Lower != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Lower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntWeightTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntWeightTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntWeightTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for iNdEx := len(m.WeightRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeightRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringInputParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringInputParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringInputParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeeInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxValue))
		i--
		dAtA[i] = 0x10
	}
	if m.MinValue != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MinValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LongInputParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongInputParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongInputParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxValue))
		i--
		dAtA[i] = 0x18
	}
	if m.MinValue != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MinValue))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LongInputParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongInputParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongInputParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ItemInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != nil {
		{
			size, err := m.TransferFee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Strings != nil {
		{
			size, err := m.Strings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Longs != nil {
		{
			size, err := m.Longs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Doubles != nil {
		{
			size, err := m.Doubles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemInputList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemInputList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemInputList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WeightedOutputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedOutputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedOutputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EntryIDs) > 0 {
		for iNdEx := len(m.EntryIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EntryIDs[iNdEx])
			copy(dAtA[i:], m.EntryIDs[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.EntryIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WeightedOutputsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedOutputsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedOutputsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rate != nil {
		{
			size, err := m.Rate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DoubleParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0x22
	}
	if m.WeightTable != nil {
		{
			size, err := m.WeightTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rate != nil {
		{
			size, err := m.Rate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleParamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleParamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleParamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ItemOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x28
	}
	if m.Strings != nil {
		{
			size, err := m.Strings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Longs != nil {
		{
			size, err := m.Longs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Doubles != nil {
		{
			size, err := m.Doubles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemModifyOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemModifyOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemModifyOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x30
	}
	if m.Strings != nil {
		{
			size, err := m.Strings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Longs != nil {
		{
			size, err := m.Longs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Doubles != nil {
		{
			size, err := m.Doubles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ItemInputRef) > 0 {
		i -= len(m.ItemInputRef)
		copy(dAtA[i:], m.ItemInputRef)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ItemInputRef)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemModifyParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemModifyParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemModifyParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x20
	}
	if m.Strings != nil {
		{
			size, err := m.Strings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Longs != nil {
		{
			size, err := m.Longs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Doubles != nil {
		{
			size, err := m.Doubles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x60
	}
	if m.LastUpdate != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x58
	}
	if m.Tradable {
		i--
		if m.Tradable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.OwnerTradeID) > 0 {
		i -= len(m.OwnerTradeID)
		copy(dAtA[i:], m.OwnerTradeID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OwnerTradeID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OwnerRecipeID) > 0 {
		i -= len(m.OwnerRecipeID)
		copy(dAtA[i:], m.OwnerRecipeID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OwnerRecipeID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeVersion != nil {
		{
			size, err := m.NodeVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DoubleKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LongKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradeItemInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeItemInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeItemInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x12
	}
	if m.ItemInput != nil {
		{
			size, err := m.ItemInput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradeItemInputList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeItemInputList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeItemInputList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CoinInputList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *CoinInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovQuery(uint64(m.Count))
	}
	return n
}

func (m *CoinOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Coin)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Count)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *SemVer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *Level) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovQuery(uint64(m.Number))
	}
	return n
}

func (m *Email) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *FloatString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DoubleInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MinValue != nil {
		l = m.MinValue.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MaxValue != nil {
		l = m.MaxValue.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DoubleInputParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *DoubleWeightRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != nil {
		l = m.Lower.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Upper != nil {
		l = m.Upper.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovQuery(uint64(m.Weight))
	}
	return n
}

func (m *DoubleWeightTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for _, e := range m.WeightRanges {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *LongParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Rate != nil {
		l = m.Rate.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.WeightTable != nil {
		l = m.WeightTable.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *LongParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *IntWeightRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovQuery(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovQuery(uint64(m.Upper))
	}
	if m.Weight != 0 {
		n += 1 + sovQuery(uint64(m.Weight))
	}
	return n
}

func (m *IntWeightTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WeightRanges) > 0 {
		for _, e := range m.WeightRanges {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *StringInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *StringInputParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *FeeInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinValue != 0 {
		n += 1 + sovQuery(uint64(m.MinValue))
	}
	if m.MaxValue != 0 {
		n += 1 + sovQuery(uint64(m.MaxValue))
	}
	return n
}

func (m *LongInputParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MinValue != 0 {
		n += 1 + sovQuery(uint64(m.MinValue))
	}
	if m.MaxValue != 0 {
		n += 1 + sovQuery(uint64(m.MaxValue))
	}
	return n
}

func (m *LongInputParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ItemInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Doubles != nil {
		l = m.Doubles.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Longs != nil {
		l = m.Longs.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Strings != nil {
		l = m.Strings.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TransferFee != nil {
		l = m.TransferFee.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ItemInputList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *WeightedOutputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EntryIDs) > 0 {
		for _, s := range m.EntryIDs {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *WeightedOutputsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *StringParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != nil {
		l = m.Rate.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *StringParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *DoubleParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != nil {
		l = m.Rate.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.WeightTable != nil {
		l = m.WeightTable.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DoubleParamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *ItemOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Doubles != nil {
		l = m.Doubles.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Longs != nil {
		l = m.Longs.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Strings != nil {
		l = m.Strings.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TransferFee != 0 {
		n += 1 + sovQuery(uint64(m.TransferFee))
	}
	return n
}

func (m *ItemModifyOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ItemInputRef)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Doubles != nil {
		l = m.Doubles.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Longs != nil {
		l = m.Longs.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Strings != nil {
		l = m.Strings.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TransferFee != 0 {
		n += 1 + sovQuery(uint64(m.TransferFee))
	}
	return n
}

func (m *ItemModifyParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Doubles != nil {
		l = m.Doubles.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Longs != nil {
		l = m.Longs.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Strings != nil {
		l = m.Strings.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TransferFee != 0 {
		n += 1 + sovQuery(uint64(m.TransferFee))
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeVersion != nil {
		l = m.NodeVersion.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OwnerRecipeID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OwnerTradeID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Tradable {
		n += 2
	}
	if m.LastUpdate != 0 {
		n += 1 + sovQuery(uint64(m.LastUpdate))
	}
	if m.TransferFee != 0 {
		n += 1 + sovQuery(uint64(m.TransferFee))
	}
	return n
}

func (m *ItemList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *DoubleKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *LongKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovQuery(uint64(m.Value))
	}
	return n
}

func (m *StringKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *TradeItemInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemInput != nil {
		l = m.ItemInput.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *TradeItemInputList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CoinInputList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinInputList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinInputList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &CoinInput{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemVer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemVer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Level) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Email) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Email: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Email: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinValue == nil {
				m.MinValue = &FloatString{}
			}
			if err := m.MinValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxValue == nil {
				m.MaxValue = &FloatString{}
			}
			if err := m.MaxValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleInputParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleInputParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleInputParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &DoubleInputParam{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleWeightRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleWeightRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleWeightRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lower == nil {
				m.Lower = &FloatString{}
			}
			if err := m.Lower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upper == nil {
				m.Upper = &FloatString{}
			}
			if err := m.Upper.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleWeightTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleWeightTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleWeightTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightRanges = append(m.WeightRanges, &DoubleWeightRange{})
			if err := m.WeightRanges[len(m.WeightRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rate == nil {
				m.Rate = &FloatString{}
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightTable == nil {
				m.WeightTable = &IntWeightTable{}
			}
			if err := m.WeightTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &LongParam{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntWeightRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntWeightRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntWeightRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntWeightTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntWeightTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntWeightTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightRanges = append(m.WeightRanges, &IntWeightRange{})
			if err := m.WeightRanges[len(m.WeightRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringInputParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringInputParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringInputParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &StringInputParam{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			m.MinValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			m.MaxValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongInputParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongInputParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongInputParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			m.MinValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			m.MaxValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongInputParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongInputParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongInputParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &LongInputParam{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doubles == nil {
				m.Doubles = &DoubleInputParamList{}
			}
			if err := m.Doubles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Longs == nil {
				m.Longs = &LongInputParamList{}
			}
			if err := m.Longs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = &StringInputParamList{}
			}
			if err := m.Strings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferFee == nil {
				m.TransferFee = &FeeInputParam{}
			}
			if err := m.TransferFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemInputList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemInputList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemInputList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ItemInput{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedOutputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedOutputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedOutputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryIDs = append(m.EntryIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedOutputsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedOutputsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedOutputsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &WeightedOutputs{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rate == nil {
				m.Rate = &FloatString{}
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &StringParam{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rate == nil {
				m.Rate = &FloatString{}
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightTable == nil {
				m.WeightTable = &DoubleWeightTable{}
			}
			if err := m.WeightTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleParamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleParamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleParamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &DoubleParam{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doubles == nil {
				m.Doubles = &DoubleParamList{}
			}
			if err := m.Doubles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Longs == nil {
				m.Longs = &LongParamList{}
			}
			if err := m.Longs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = &StringParamList{}
			}
			if err := m.Strings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemModifyOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemModifyOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemModifyOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInputRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doubles == nil {
				m.Doubles = &DoubleParamList{}
			}
			if err := m.Doubles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Longs == nil {
				m.Longs = &LongParamList{}
			}
			if err := m.Longs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = &StringParamList{}
			}
			if err := m.Strings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemModifyParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemModifyParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemModifyParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doubles == nil {
				m.Doubles = &DoubleParamList{}
			}
			if err := m.Doubles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Longs == nil {
				m.Longs = &LongParamList{}
			}
			if err := m.Longs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = &StringParamList{}
			}
			if err := m.Strings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeVersion == nil {
				m.NodeVersion = &SemVer{}
			}
			if err := m.NodeVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, &DoubleKeyValue{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, &LongKeyValue{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, &StringKeyValue{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerRecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerRecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerTradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerTradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tradable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tradable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Item{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &FloatString{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeItemInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeItemInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeItemInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInput == nil {
				m.ItemInput = &ItemInput{}
			}
			if err := m.ItemInput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeItemInputList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeItemInputList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeItemInputList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TradeItemInput{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)

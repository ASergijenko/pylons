// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pylons/msgs.proto

package msgs

import (
	fmt "fmt"
	github_com_Pylons_tech_pylons_x_pylons_types "github.com/Pylons-tech/pylons/x/pylons/types"
	types "github.com/Pylons-tech/pylons/x/pylons/types"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCheckExecution defines a CheckExecution message
type MsgCheckExecution struct {
	ExecID string `protobuf:"bytes,1,opt,name=ExecID,proto3" json:"ExecID,omitempty"`
	Sender string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	// if this is set to true then we complete the execution by paying for it
	PayToComplete bool `protobuf:"varint,3,opt,name=PayToComplete,proto3" json:"PayToComplete,omitempty"`
}

func (m *MsgCheckExecution) Reset()         { *m = MsgCheckExecution{} }
func (m *MsgCheckExecution) String() string { return proto.CompactTextString(m) }
func (*MsgCheckExecution) ProtoMessage()    {}
func (*MsgCheckExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{0}
}
func (m *MsgCheckExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCheckExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCheckExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCheckExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCheckExecution.Merge(m, src)
}
func (m *MsgCheckExecution) XXX_Size() int {
	return m.Size()
}
func (m *MsgCheckExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCheckExecution.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCheckExecution proto.InternalMessageInfo

func (m *MsgCheckExecution) GetExecID() string {
	if m != nil {
		return m.ExecID
	}
	return ""
}

func (m *MsgCheckExecution) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCheckExecution) GetPayToComplete() bool {
	if m != nil {
		return m.PayToComplete
	}
	return false
}

// MsgCreateAccount defines a CreateAccount message
type MsgCreateAccount struct {
	Requester string `protobuf:"bytes,1,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgCreateAccount) Reset()         { *m = MsgCreateAccount{} }
func (m *MsgCreateAccount) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAccount) ProtoMessage()    {}
func (*MsgCreateAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{1}
}
func (m *MsgCreateAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAccount.Merge(m, src)
}
func (m *MsgCreateAccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAccount proto.InternalMessageInfo

func (m *MsgCreateAccount) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

//Cookbook is a struct that contains all the metadata of a cookbook
type MsgCreateCookbook struct {
	// optinal id which can be provided by the developer
	CookbookID   string        `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Name         string        `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Description  string        `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      *types.SemVer `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string        `protobuf:"bytes,5,opt,name=Developer,proto3" json:"Developer,omitempty"`
	SupportEmail *types.Email  `protobuf:"bytes,6,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	Level        *types.Level  `protobuf:"bytes,7,opt,name=Level,proto3" json:"Level,omitempty"`
	Sender       string        `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	// Pylons per block to be charged across this cookbook for delayed execution early completion
	CostPerBlock int64 `protobuf:"varint,9,opt,name=CostPerBlock,proto3" json:"CostPerBlock,omitempty"`
}

func (m *MsgCreateCookbook) Reset()         { *m = MsgCreateCookbook{} }
func (m *MsgCreateCookbook) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCookbook) ProtoMessage()    {}
func (*MsgCreateCookbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{2}
}
func (m *MsgCreateCookbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCookbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCookbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCookbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCookbook.Merge(m, src)
}
func (m *MsgCreateCookbook) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCookbook) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCookbook.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCookbook proto.InternalMessageInfo

func (m *MsgCreateCookbook) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgCreateCookbook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateCookbook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateCookbook) GetVersion() *types.SemVer {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *MsgCreateCookbook) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *MsgCreateCookbook) GetSupportEmail() *types.Email {
	if m != nil {
		return m.SupportEmail
	}
	return nil
}

func (m *MsgCreateCookbook) GetLevel() *types.Level {
	if m != nil {
		return m.Level
	}
	return nil
}

func (m *MsgCreateCookbook) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreateCookbook) GetCostPerBlock() int64 {
	if m != nil {
		return m.CostPerBlock
	}
	return 0
}

// MsgCreateRecipe defines a CreateRecipe message
type MsgCreateRecipe struct {
	// optional RecipeID if someone
	RecipeID      string                                                   `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Name          string                                                   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	CookbookID    string                                                   `protobuf:"bytes,3,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	CoinInputs    *types.CoinInputList                                     `protobuf:"bytes,4,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs    *types.ItemInputList                                     `protobuf:"bytes,5,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	Outputs       *types.WeightedOutputsList                               `protobuf:"bytes,6,opt,name=Outputs,proto3" json:"Outputs,omitempty"`
	BlockInterval int64                                                    `protobuf:"varint,7,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string                                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Description   string                                                   `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	Entries       github_com_Pylons_tech_pylons_x_pylons_types.EntriesList `protobuf:"bytes,10,rep,name=Entries,proto3,castrepeated=github.com/Pylons-tech/pylons/x/pylons/types.EntriesList" json:"Entries,omitempty"`
}

func (m *MsgCreateRecipe) Reset()         { *m = MsgCreateRecipe{} }
func (m *MsgCreateRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRecipe) ProtoMessage()    {}
func (*MsgCreateRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{3}
}
func (m *MsgCreateRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRecipe.Merge(m, src)
}
func (m *MsgCreateRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRecipe proto.InternalMessageInfo

func (m *MsgCreateRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgCreateRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateRecipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgCreateRecipe) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetItemInputs() *types.ItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetOutputs() *types.WeightedOutputsList {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *MsgCreateRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreateRecipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateRecipe) GetEntries() github_com_Pylons_tech_pylons_x_pylons_types.EntriesList {
	if m != nil {
		return m.Entries
	}
	return nil
}

// MsgCreateTrade defines a CreateTrade message
type MsgCreateTrade struct {
	CoinInputs  *types.CoinInputList                     `protobuf:"bytes,1,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs  *types.TradeItemInputList                `protobuf:"bytes,2,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	CoinOutputs github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=CoinOutputs,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinOutputs"`
	ItemOutputs *types.ItemList                          `protobuf:"bytes,4,opt,name=ItemOutputs,proto3" json:"ItemOutputs,omitempty"`
	ExtraInfo   string                                   `protobuf:"bytes,5,opt,name=ExtraInfo,proto3" json:"ExtraInfo,omitempty"`
	Sender      string                                   `protobuf:"bytes,6,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgCreateTrade) Reset()         { *m = MsgCreateTrade{} }
func (m *MsgCreateTrade) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrade) ProtoMessage()    {}
func (*MsgCreateTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{4}
}
func (m *MsgCreateTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrade.Merge(m, src)
}
func (m *MsgCreateTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrade proto.InternalMessageInfo

func (m *MsgCreateTrade) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgCreateTrade) GetItemInputs() *types.TradeItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgCreateTrade) GetCoinOutputs() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinOutputs
	}
	return nil
}

func (m *MsgCreateTrade) GetItemOutputs() *types.ItemList {
	if m != nil {
		return m.ItemOutputs
	}
	return nil
}

func (m *MsgCreateTrade) GetExtraInfo() string {
	if m != nil {
		return m.ExtraInfo
	}
	return ""
}

func (m *MsgCreateTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgDisableRecipe defines a DisableRecipe message
type MsgDisableRecipe struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgDisableRecipe) Reset()         { *m = MsgDisableRecipe{} }
func (m *MsgDisableRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgDisableRecipe) ProtoMessage()    {}
func (*MsgDisableRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{5}
}
func (m *MsgDisableRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableRecipe.Merge(m, src)
}
func (m *MsgDisableRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableRecipe proto.InternalMessageInfo

func (m *MsgDisableRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgDisableRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgDisableTrade defines a DisableTrade message
type MsgDisableTrade struct {
	TradeID string `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgDisableTrade) Reset()         { *m = MsgDisableTrade{} }
func (m *MsgDisableTrade) String() string { return proto.CompactTextString(m) }
func (*MsgDisableTrade) ProtoMessage()    {}
func (*MsgDisableTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{6}
}
func (m *MsgDisableTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableTrade.Merge(m, src)
}
func (m *MsgDisableTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableTrade proto.InternalMessageInfo

func (m *MsgDisableTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgDisableTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgEnableRecipe defines a EnableRecipe message
type MsgEnableRecipe struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgEnableRecipe) Reset()         { *m = MsgEnableRecipe{} }
func (m *MsgEnableRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgEnableRecipe) ProtoMessage()    {}
func (*MsgEnableRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{7}
}
func (m *MsgEnableRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableRecipe.Merge(m, src)
}
func (m *MsgEnableRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableRecipe proto.InternalMessageInfo

func (m *MsgEnableRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgEnableRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgEnableTrade defines a EnableTrade message
type MsgEnableTrade struct {
	TradeID string `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgEnableTrade) Reset()         { *m = MsgEnableTrade{} }
func (m *MsgEnableTrade) String() string { return proto.CompactTextString(m) }
func (*MsgEnableTrade) ProtoMessage()    {}
func (*MsgEnableTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{8}
}
func (m *MsgEnableTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableTrade.Merge(m, src)
}
func (m *MsgEnableTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableTrade proto.InternalMessageInfo

func (m *MsgEnableTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgEnableTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgExecuteRecipe defines a SetName message
type MsgExecuteRecipe struct {
	RecipeID string   `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemIDs  []string `protobuf:"bytes,3,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
}

func (m *MsgExecuteRecipe) Reset()         { *m = MsgExecuteRecipe{} }
func (m *MsgExecuteRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgExecuteRecipe) ProtoMessage()    {}
func (*MsgExecuteRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{9}
}
func (m *MsgExecuteRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExecuteRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExecuteRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExecuteRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExecuteRecipe.Merge(m, src)
}
func (m *MsgExecuteRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgExecuteRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExecuteRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExecuteRecipe proto.InternalMessageInfo

func (m *MsgExecuteRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgExecuteRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgExecuteRecipe) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

// MsgFiatItem is a msg struct to be used to fiat item
type MsgFiatItem struct {
	CookbookID  string                  `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Doubles     []*types.DoubleKeyValue `protobuf:"bytes,2,rep,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs       []*types.LongKeyValue   `protobuf:"bytes,3,rep,name=Longs,proto3" json:"Longs,omitempty"`
	Strings     []*types.StringKeyValue `protobuf:"bytes,4,rep,name=Strings,proto3" json:"Strings,omitempty"`
	Sender      string                  `protobuf:"bytes,5,opt,name=Sender,proto3" json:"Sender,omitempty"`
	TransferFee int64                   `protobuf:"varint,6,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *MsgFiatItem) Reset()         { *m = MsgFiatItem{} }
func (m *MsgFiatItem) String() string { return proto.CompactTextString(m) }
func (*MsgFiatItem) ProtoMessage()    {}
func (*MsgFiatItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{10}
}
func (m *MsgFiatItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFiatItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFiatItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFiatItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFiatItem.Merge(m, src)
}
func (m *MsgFiatItem) XXX_Size() int {
	return m.Size()
}
func (m *MsgFiatItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFiatItem.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFiatItem proto.InternalMessageInfo

func (m *MsgFiatItem) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgFiatItem) GetDoubles() []*types.DoubleKeyValue {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *MsgFiatItem) GetLongs() []*types.LongKeyValue {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *MsgFiatItem) GetStrings() []*types.StringKeyValue {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *MsgFiatItem) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgFiatItem) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// MsgFulfillTrade defines a FulfillTrade message
type MsgFulfillTrade struct {
	TradeID string   `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemIDs []string `protobuf:"bytes,3,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
}

func (m *MsgFulfillTrade) Reset()         { *m = MsgFulfillTrade{} }
func (m *MsgFulfillTrade) String() string { return proto.CompactTextString(m) }
func (*MsgFulfillTrade) ProtoMessage()    {}
func (*MsgFulfillTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{11}
}
func (m *MsgFulfillTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfillTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfillTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfillTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfillTrade.Merge(m, src)
}
func (m *MsgFulfillTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfillTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfillTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfillTrade proto.InternalMessageInfo

func (m *MsgFulfillTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgFulfillTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgFulfillTrade) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

// MsgGetPylons defines a GetPylons message
type MsgGetPylons struct {
	Amount    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
	Requester string                                   `protobuf:"bytes,2,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgGetPylons) Reset()         { *m = MsgGetPylons{} }
func (m *MsgGetPylons) String() string { return proto.CompactTextString(m) }
func (*MsgGetPylons) ProtoMessage()    {}
func (*MsgGetPylons) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{12}
}
func (m *MsgGetPylons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGetPylons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGetPylons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGetPylons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGetPylons.Merge(m, src)
}
func (m *MsgGetPylons) XXX_Size() int {
	return m.Size()
}
func (m *MsgGetPylons) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGetPylons.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGetPylons proto.InternalMessageInfo

func (m *MsgGetPylons) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgGetPylons) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// MsgGoogleIAPGetPylons defines a GetPylons message
type MsgGoogleIAPGetPylons struct {
	ProductID         string `protobuf:"bytes,1,opt,name=ProductID,proto3" json:"ProductID,omitempty"`
	PurchaseToken     string `protobuf:"bytes,2,opt,name=PurchaseToken,proto3" json:"PurchaseToken,omitempty"`
	ReceiptDataBase64 string `protobuf:"bytes,3,opt,name=ReceiptDataBase64,proto3" json:"ReceiptDataBase64,omitempty"`
	Signature         string `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	Requester         string `protobuf:"bytes,5,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgGoogleIAPGetPylons) Reset()         { *m = MsgGoogleIAPGetPylons{} }
func (m *MsgGoogleIAPGetPylons) String() string { return proto.CompactTextString(m) }
func (*MsgGoogleIAPGetPylons) ProtoMessage()    {}
func (*MsgGoogleIAPGetPylons) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{13}
}
func (m *MsgGoogleIAPGetPylons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGoogleIAPGetPylons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGoogleIAPGetPylons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGoogleIAPGetPylons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGoogleIAPGetPylons.Merge(m, src)
}
func (m *MsgGoogleIAPGetPylons) XXX_Size() int {
	return m.Size()
}
func (m *MsgGoogleIAPGetPylons) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGoogleIAPGetPylons.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGoogleIAPGetPylons proto.InternalMessageInfo

func (m *MsgGoogleIAPGetPylons) GetProductID() string {
	if m != nil {
		return m.ProductID
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetPurchaseToken() string {
	if m != nil {
		return m.PurchaseToken
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetReceiptDataBase64() string {
	if m != nil {
		return m.ReceiptDataBase64
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// MsgSendCoins defines a SendCoins message
type MsgSendCoins struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
	Sender   string                                   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Receiver string                                   `protobuf:"bytes,3,opt,name=Receiver,proto3" json:"Receiver,omitempty"`
}

func (m *MsgSendCoins) Reset()         { *m = MsgSendCoins{} }
func (m *MsgSendCoins) String() string { return proto.CompactTextString(m) }
func (*MsgSendCoins) ProtoMessage()    {}
func (*MsgSendCoins) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{14}
}
func (m *MsgSendCoins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendCoins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendCoins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendCoins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendCoins.Merge(m, src)
}
func (m *MsgSendCoins) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendCoins) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendCoins.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendCoins proto.InternalMessageInfo

func (m *MsgSendCoins) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgSendCoins) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSendCoins) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// MsgSendItems defines a SendItems message
type MsgSendItems struct {
	ItemIDs  []string `protobuf:"bytes,1,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
	Sender   string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Receiver string   `protobuf:"bytes,3,opt,name=Receiver,proto3" json:"Receiver,omitempty"`
}

func (m *MsgSendItems) Reset()         { *m = MsgSendItems{} }
func (m *MsgSendItems) String() string { return proto.CompactTextString(m) }
func (*MsgSendItems) ProtoMessage()    {}
func (*MsgSendItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{15}
}
func (m *MsgSendItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendItems.Merge(m, src)
}
func (m *MsgSendItems) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendItems) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendItems.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendItems proto.InternalMessageInfo

func (m *MsgSendItems) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

func (m *MsgSendItems) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSendItems) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// MsgUpdateItemString defines a UpdateItemString message
type MsgUpdateItemString struct {
	Field  string `protobuf:"bytes,1,opt,name=Field,proto3" json:"Field,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	Sender string `protobuf:"bytes,3,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemID string `protobuf:"bytes,4,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
}

func (m *MsgUpdateItemString) Reset()         { *m = MsgUpdateItemString{} }
func (m *MsgUpdateItemString) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateItemString) ProtoMessage()    {}
func (*MsgUpdateItemString) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{16}
}
func (m *MsgUpdateItemString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateItemString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateItemString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateItemString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateItemString.Merge(m, src)
}
func (m *MsgUpdateItemString) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateItemString) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateItemString.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateItemString proto.InternalMessageInfo

func (m *MsgUpdateItemString) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *MsgUpdateItemString) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MsgUpdateItemString) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgUpdateItemString) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

// MsgUpdateCookbook defines a UpdateCookbook message
type MsgUpdateCookbook struct {
	ID           string        `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Description  string        `protobuf:"bytes,2,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      *types.SemVer `protobuf:"bytes,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string        `protobuf:"bytes,4,opt,name=Developer,proto3" json:"Developer,omitempty"`
	SupportEmail *types.Email  `protobuf:"bytes,5,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	Sender       string        `protobuf:"bytes,6,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgUpdateCookbook) Reset()         { *m = MsgUpdateCookbook{} }
func (m *MsgUpdateCookbook) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCookbook) ProtoMessage()    {}
func (*MsgUpdateCookbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{17}
}
func (m *MsgUpdateCookbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCookbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCookbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCookbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCookbook.Merge(m, src)
}
func (m *MsgUpdateCookbook) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCookbook) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCookbook.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCookbook proto.InternalMessageInfo

func (m *MsgUpdateCookbook) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MsgUpdateCookbook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgUpdateCookbook) GetVersion() *types.SemVer {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *MsgUpdateCookbook) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *MsgUpdateCookbook) GetSupportEmail() *types.Email {
	if m != nil {
		return m.SupportEmail
	}
	return nil
}

func (m *MsgUpdateCookbook) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgUpdateRecipe defines a UpdateRecipe message
type MsgUpdateRecipe struct {
	Name          string                                                   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	CookbookID    string                                                   `protobuf:"bytes,2,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	ID            string                                                   `protobuf:"bytes,3,opt,name=ID,proto3" json:"ID,omitempty"`
	CoinInputs    *types.CoinInputList                                     `protobuf:"bytes,4,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs    *types.ItemInputList                                     `protobuf:"bytes,5,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	Outputs       *types.WeightedOutputsList                               `protobuf:"bytes,6,opt,name=Outputs,proto3" json:"Outputs,omitempty"`
	BlockInterval int64                                                    `protobuf:"varint,7,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string                                                   `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Description   string                                                   `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	Entries       github_com_Pylons_tech_pylons_x_pylons_types.EntriesList `protobuf:"bytes,10,rep,name=Entries,proto3,castrepeated=github.com/Pylons-tech/pylons/x/pylons/types.EntriesList" json:"Entries,omitempty"`
}

func (m *MsgUpdateRecipe) Reset()         { *m = MsgUpdateRecipe{} }
func (m *MsgUpdateRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRecipe) ProtoMessage()    {}
func (*MsgUpdateRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{18}
}
func (m *MsgUpdateRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRecipe.Merge(m, src)
}
func (m *MsgUpdateRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRecipe proto.InternalMessageInfo

func (m *MsgUpdateRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateRecipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgUpdateRecipe) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MsgUpdateRecipe) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetItemInputs() *types.ItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetOutputs() *types.WeightedOutputsList {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *MsgUpdateRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgUpdateRecipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgUpdateRecipe) GetEntries() github_com_Pylons_tech_pylons_x_pylons_types.EntriesList {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*MsgCheckExecution)(nil), "pylons.MsgCheckExecution")
	proto.RegisterType((*MsgCreateAccount)(nil), "pylons.MsgCreateAccount")
	proto.RegisterType((*MsgCreateCookbook)(nil), "pylons.MsgCreateCookbook")
	proto.RegisterType((*MsgCreateRecipe)(nil), "pylons.MsgCreateRecipe")
	proto.RegisterType((*MsgCreateTrade)(nil), "pylons.MsgCreateTrade")
	proto.RegisterType((*MsgDisableRecipe)(nil), "pylons.MsgDisableRecipe")
	proto.RegisterType((*MsgDisableTrade)(nil), "pylons.MsgDisableTrade")
	proto.RegisterType((*MsgEnableRecipe)(nil), "pylons.MsgEnableRecipe")
	proto.RegisterType((*MsgEnableTrade)(nil), "pylons.MsgEnableTrade")
	proto.RegisterType((*MsgExecuteRecipe)(nil), "pylons.MsgExecuteRecipe")
	proto.RegisterType((*MsgFiatItem)(nil), "pylons.MsgFiatItem")
	proto.RegisterType((*MsgFulfillTrade)(nil), "pylons.MsgFulfillTrade")
	proto.RegisterType((*MsgGetPylons)(nil), "pylons.MsgGetPylons")
	proto.RegisterType((*MsgGoogleIAPGetPylons)(nil), "pylons.MsgGoogleIAPGetPylons")
	proto.RegisterType((*MsgSendCoins)(nil), "pylons.MsgSendCoins")
	proto.RegisterType((*MsgSendItems)(nil), "pylons.MsgSendItems")
	proto.RegisterType((*MsgUpdateItemString)(nil), "pylons.MsgUpdateItemString")
	proto.RegisterType((*MsgUpdateCookbook)(nil), "pylons.MsgUpdateCookbook")
	proto.RegisterType((*MsgUpdateRecipe)(nil), "pylons.MsgUpdateRecipe")
}

func init() { proto.RegisterFile("pylons/msgs.proto", fileDescriptor_c904270567374406) }

var fileDescriptor_c904270567374406 = []byte{
	// 1170 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0xaf, 0xe3, 0x26, 0xd9, 0x4c, 0xba, 0xfd, 0x6e, 0xfd, 0xed, 0x56, 0xd9, 0x52, 0xa5, 0x91,
	0xe1, 0x10, 0x01, 0x9b, 0xb4, 0x85, 0x45, 0x08, 0x71, 0x69, 0x9a, 0x14, 0x45, 0xb4, 0x50, 0xb9,
	0xa5, 0x48, 0x08, 0x24, 0x26, 0xce, 0xab, 0x6b, 0xc5, 0xf1, 0xb8, 0x33, 0xe3, 0xaa, 0xfd, 0x2f,
	0xe0, 0xaf, 0x40, 0xda, 0x23, 0x7f, 0x00, 0x37, 0xa4, 0x3d, 0xee, 0x71, 0x0f, 0x88, 0x45, 0xed,
	0x1f, 0xc1, 0x15, 0xcd, 0x0f, 0x3b, 0x76, 0x4b, 0xb6, 0xa5, 0x0b, 0x9c, 0x38, 0xc5, 0xef, 0xf3,
	0x7e, 0xcc, 0x9b, 0xcf, 0xbc, 0x79, 0xf3, 0x82, 0x16, 0xa2, 0xf3, 0x80, 0x84, 0xac, 0x3d, 0x66,
	0x1e, 0x6b, 0x45, 0x94, 0x70, 0x62, 0x95, 0x14, 0xb4, 0xbc, 0xe8, 0x11, 0x8f, 0x48, 0xa8, 0x2d,
	0xbe, 0x94, 0x76, 0xf9, 0x91, 0x47, 0x88, 0x17, 0x40, 0x5b, 0x4a, 0x83, 0xf8, 0xa8, 0x8d, 0xc3,
	0x73, 0xad, 0x5a, 0xd1, 0x2a, 0x1c, 0xf9, 0x6d, 0x1c, 0x86, 0x84, 0x63, 0xee, 0x93, 0x50, 0x87,
	0x5d, 0xae, 0xbb, 0x84, 0x8d, 0x09, 0x6b, 0x0f, 0x30, 0x83, 0xf6, 0xe9, 0xfa, 0x00, 0x38, 0x5e,
	0x6f, 0xbb, 0xc4, 0x0f, 0xb5, 0xde, 0xd2, 0x99, 0x9c, 0xc4, 0x40, 0x75, 0x44, 0xdb, 0x47, 0x0b,
	0xbb, 0xcc, 0xdb, 0x3a, 0x06, 0x77, 0xd4, 0x3b, 0x03, 0x37, 0x16, 0xf1, 0xac, 0x25, 0x54, 0x12,
	0x42, 0xbf, 0x5b, 0x33, 0x1a, 0x46, 0xb3, 0xe2, 0x68, 0x49, 0xe0, 0xfb, 0x10, 0x0e, 0x81, 0xd6,
	0x0a, 0x0a, 0x57, 0x92, 0xf5, 0x16, 0xba, 0xbf, 0x87, 0xcf, 0x0f, 0xc8, 0x16, 0x19, 0x47, 0x01,
	0x70, 0xa8, 0x99, 0x0d, 0xa3, 0x79, 0xcf, 0xc9, 0x83, 0xf6, 0x1a, 0x7a, 0x20, 0x96, 0xa2, 0x80,
	0x39, 0x6c, 0xba, 0x2e, 0x89, 0x43, 0x6e, 0xad, 0xa0, 0x8a, 0x03, 0x27, 0x31, 0x30, 0x0e, 0x54,
	0x2f, 0x36, 0x01, 0xec, 0x9f, 0x0b, 0x2a, 0x3b, 0xe9, 0xb2, 0x45, 0xc8, 0x68, 0x40, 0xc8, 0xc8,
	0xaa, 0x23, 0x94, 0x7c, 0xa7, 0x19, 0x66, 0x10, 0xcb, 0x42, 0xb3, 0x9f, 0xe1, 0x31, 0xe8, 0x1c,
	0xe5, 0xb7, 0xd5, 0x40, 0xd5, 0x2e, 0x30, 0x97, 0xfa, 0x91, 0xd8, 0xa0, 0xcc, 0xaf, 0xe2, 0x64,
	0x21, 0xab, 0x89, 0xca, 0x87, 0x40, 0x99, 0xd0, 0xce, 0x36, 0x8c, 0x66, 0x75, 0x63, 0xbe, 0xa5,
	0xe8, 0x6a, 0xed, 0xc3, 0xf8, 0x10, 0xa8, 0x93, 0xa8, 0x45, 0xce, 0x5d, 0x38, 0x85, 0x80, 0x44,
	0x40, 0x6b, 0x45, 0x95, 0x73, 0x0a, 0x58, 0xeb, 0x68, 0x6e, 0x3f, 0x8e, 0x22, 0x42, 0x79, 0x6f,
	0x8c, 0xfd, 0xa0, 0x56, 0x92, 0xc1, 0xee, 0x27, 0xc1, 0x24, 0xe8, 0xe4, 0x4c, 0xac, 0x37, 0x51,
	0x71, 0x47, 0xf8, 0xd7, 0xca, 0x79, 0x5b, 0x09, 0x3a, 0x4a, 0x97, 0xe1, 0xfe, 0x5e, 0x8e, 0x7b,
	0x1b, 0xcd, 0x6d, 0x11, 0xc6, 0xf7, 0x80, 0x76, 0x02, 0xe2, 0x8e, 0x6a, 0x95, 0x86, 0xd1, 0x34,
	0x9d, 0x1c, 0x66, 0xff, 0x64, 0xa2, 0xff, 0xa5, 0x3c, 0x3a, 0xe0, 0xfa, 0x11, 0x58, 0xcb, 0xe8,
	0x9e, 0xfa, 0x4a, 0x39, 0x4c, 0xe5, 0x3f, 0x65, 0x30, 0xcf, 0xba, 0x79, 0x8d, 0xf5, 0x27, 0x42,
	0xef, 0x87, 0xfd, 0x30, 0x8a, 0x39, 0xd3, 0x14, 0x3e, 0x4c, 0x76, 0x92, 0x6a, 0x76, 0x7c, 0xc6,
	0x9d, 0x8c, 0xa1, 0x70, 0xeb, 0x73, 0x18, 0x6b, 0xb7, 0x62, 0xde, 0x2d, 0xd5, 0x28, 0xb7, 0x89,
	0xa1, 0xf5, 0x04, 0x95, 0x3f, 0x8f, 0xb9, 0xf4, 0x51, 0x04, 0xbf, 0x91, 0xf8, 0x7c, 0x09, 0xbe,
	0x77, 0xcc, 0x61, 0xa8, 0xd5, 0xd2, 0x33, 0xb1, 0x15, 0x85, 0x2a, 0x19, 0xe9, 0x87, 0x1c, 0xe8,
	0x29, 0x56, 0x8c, 0x9b, 0x4e, 0x1e, 0x9c, 0x4a, 0xf5, 0x95, 0x22, 0xaa, 0x5c, 0x2f, 0xa2, 0x43,
	0x54, 0xee, 0x85, 0x9c, 0xfa, 0xc0, 0x6a, 0xa8, 0x61, 0x36, 0xe7, 0x3a, 0x1f, 0x3f, 0x7d, 0xb9,
	0xfa, 0xa1, 0xe7, 0xf3, 0xe3, 0x78, 0xd0, 0x72, 0xc9, 0xb8, 0xbd, 0x27, 0x93, 0x7c, 0xcc, 0xc1,
	0x3d, 0x6e, 0xeb, 0xdb, 0x78, 0x96, 0x7c, 0xf0, 0xf3, 0x08, 0x58, 0x4b, 0xfb, 0xab, 0xbc, 0xb5,
	0x60, 0xff, 0x52, 0x40, 0xf3, 0xe9, 0x01, 0x1e, 0x50, 0x3c, 0x84, 0x2b, 0x7c, 0x1b, 0xb7, 0xe5,
	0xfb, 0xa3, 0x1c, 0xdf, 0x05, 0xe9, 0xb6, 0x9c, 0xb8, 0xc9, 0xc8, 0xd3, 0x49, 0x1f, 0xa3, 0xaa,
	0x88, 0x94, 0x10, 0x6f, 0x36, 0xcc, 0x66, 0x75, 0xe3, 0x51, 0x4b, 0x75, 0x9d, 0x96, 0xe8, 0x3a,
	0x2d, 0xdd, 0x75, 0x64, 0x02, 0x9d, 0xb5, 0x67, 0xbf, 0xae, 0xce, 0x3c, 0x7d, 0xb9, 0xda, 0xcc,
	0x10, 0xa0, 0x5b, 0x94, 0xfa, 0x79, 0xcc, 0x86, 0x23, 0xbd, 0x6d, 0xe1, 0xc0, 0x9c, 0x6c, 0x7c,
	0x6b, 0x03, 0x55, 0xc5, 0xe2, 0xc9, 0x72, 0xaa, 0xa4, 0x1e, 0x64, 0x6b, 0x43, 0x66, 0x98, 0x35,
	0x12, 0x77, 0xb3, 0x77, 0xc6, 0x29, 0xee, 0x87, 0x47, 0x24, 0xb9, 0x9b, 0x29, 0x90, 0x39, 0xd8,
	0x52, 0xf6, 0x60, 0xed, 0x6d, 0xd9, 0x99, 0xba, 0x3e, 0xc3, 0x83, 0xe0, 0x36, 0xf7, 0x63, 0x4a,
	0x1f, 0xb4, 0xb7, 0xe4, 0x35, 0xd3, 0x71, 0xd4, 0x31, 0xd5, 0x50, 0x59, 0xb1, 0x9a, 0x44, 0x49,
	0xc4, 0xa9, 0x41, 0x7a, 0x32, 0x48, 0x2f, 0x7c, 0xcd, 0x5c, 0x3a, 0xb2, 0x62, 0x54, 0x98, 0xbb,
	0xa6, 0xf2, 0xad, 0xe4, 0x45, 0xbd, 0x0b, 0xaf, 0x91, 0x8b, 0x58, 0x59, 0x96, 0x51, 0x57, 0x15,
	0x4d, 0xc5, 0x49, 0x44, 0xfb, 0x77, 0x03, 0x55, 0x77, 0x99, 0xb7, 0xed, 0x63, 0x2e, 0xa0, 0x1b,
	0x7b, 0xfb, 0x1a, 0x2a, 0x77, 0x49, 0x3c, 0x08, 0x40, 0xd4, 0xae, 0x28, 0xbf, 0xa5, 0xa4, 0x1e,
	0x14, 0xfc, 0x29, 0x9c, 0x1f, 0xe2, 0x20, 0x06, 0x27, 0x31, 0xb3, 0xde, 0x46, 0xc5, 0x1d, 0x12,
	0x7a, 0x49, 0xb9, 0x2e, 0xa6, 0xcd, 0x95, 0x84, 0x5e, 0x6a, 0xad, 0x4c, 0x44, 0xf4, 0x7d, 0x4e,
	0x7d, 0x61, 0x3d, 0x9b, 0x8f, 0xae, 0xe0, 0x49, 0x74, 0x6d, 0x96, 0xd9, 0x71, 0xf1, 0x6a, 0xab,
	0x38, 0xa0, 0x38, 0x64, 0x47, 0x40, 0xb7, 0x01, 0x64, 0xb9, 0x99, 0x4e, 0x16, 0xb2, 0xbf, 0x91,
	0xc7, 0xbc, 0x1d, 0x07, 0x47, 0x7e, 0x10, 0xdc, 0xf1, 0x80, 0x5e, 0x41, 0xec, 0xf7, 0x06, 0x9a,
	0xdb, 0x65, 0xde, 0x27, 0xc0, 0x55, 0xcb, 0xb1, 0x5c, 0x54, 0xda, 0x1c, 0x8b, 0x37, 0xb7, 0x66,
	0xfc, 0xfd, 0xf7, 0x56, 0x87, 0xce, 0x3f, 0xe7, 0x85, 0x6b, 0xcf, 0xb9, 0x81, 0x1e, 0x8a, 0x9c,
	0xe4, 0x0c, 0xd3, 0xdf, 0xdc, 0x9b, 0x24, 0xb7, 0x82, 0x2a, 0x7b, 0x94, 0x0c, 0x63, 0x97, 0xa7,
	0x7b, 0x9f, 0x00, 0x72, 0xbc, 0x88, 0xa9, 0x7b, 0x8c, 0x19, 0x1c, 0x90, 0x11, 0x84, 0x3a, 0x72,
	0x1e, 0xb4, 0xde, 0x45, 0x0b, 0x0e, 0xb8, 0xe0, 0x47, 0xbc, 0x8b, 0x39, 0xee, 0x60, 0x06, 0x1f,
	0xbc, 0xaf, 0xdf, 0xa9, 0xeb, 0x0a, 0xb1, 0xe2, 0xbe, 0xef, 0x85, 0x98, 0xc7, 0x14, 0x64, 0x6b,
	0xa9, 0x38, 0x13, 0x20, 0xbf, 0x8f, 0xe2, 0xd5, 0x7d, 0xfc, 0xa0, 0xb8, 0x15, 0x67, 0x20, 0xb7,
	0xff, 0xef, 0x70, 0x3b, 0xad, 0x06, 0xd4, 0x85, 0x04, 0xff, 0x14, 0xa8, 0xde, 0x6e, 0x2a, 0xdb,
	0x5f, 0xa7, 0x89, 0x8a, 0xba, 0x60, 0xd9, 0x7a, 0x31, 0x72, 0xf5, 0x72, 0xa7, 0xe8, 0x27, 0xe8,
	0xff, 0xbb, 0xcc, 0xfb, 0x22, 0x1a, 0x62, 0x2e, 0x5f, 0x0d, 0x75, 0x29, 0xac, 0x45, 0x54, 0xdc,
	0xf6, 0x21, 0x18, 0xea, 0x83, 0x54, 0x82, 0x40, 0xe5, 0xdd, 0xd1, 0xf1, 0x95, 0x90, 0x59, 0xd6,
	0xcc, 0x2d, 0xbb, 0x84, 0x4a, 0x2a, 0x33, 0x7d, 0x36, 0x5a, 0xb2, 0x5f, 0x18, 0x72, 0x22, 0x54,
	0x6b, 0xa6, 0x13, 0xe1, 0x3c, 0x2a, 0xa4, 0x75, 0x53, 0xe8, 0x77, 0xaf, 0x3e, 0xd4, 0x85, 0x57,
	0x4e, 0x7b, 0xe6, 0x5f, 0x98, 0xf6, 0x66, 0x6f, 0x9a, 0xf6, 0x8a, 0x37, 0x4f, 0x7b, 0xd3, 0x1e,
	0xa1, 0x1f, 0xd5, 0x90, 0xa6, 0xb6, 0xa6, 0x9b, 0x6d, 0x32, 0x88, 0x19, 0x53, 0x07, 0xb1, 0xc2,
	0xb5, 0x16, 0xa9, 0xc8, 0x30, 0x53, 0x32, 0xfe, 0x1b, 0xcc, 0xfe, 0xb9, 0xc1, 0xac, 0xd3, 0x7b,
	0x76, 0x51, 0x37, 0x9e, 0x5f, 0xd4, 0x8d, 0xdf, 0x2e, 0xea, 0xc6, 0x77, 0x97, 0xf5, 0x99, 0xe7,
	0x97, 0xf5, 0x99, 0x17, 0x97, 0xf5, 0x99, 0xaf, 0xde, 0xb9, 0x65, 0x70, 0xf1, 0xb7, 0x70, 0x50,
	0x92, 0x7f, 0xc6, 0xde, 0xfb, 0x23, 0x00, 0x00, 0xff, 0xff, 0xa1, 0xa3, 0x82, 0xf9, 0x2c, 0x0e,
	0x00, 0x00,
}

func (m *MsgCheckExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCheckExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCheckExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayToComplete {
		i--
		if m.PayToComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExecID) > 0 {
		i -= len(m.ExecID)
		copy(dAtA[i:], m.ExecID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ExecID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCookbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCookbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCookbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CostPerBlock != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.CostPerBlock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.Level != nil {
		{
			size, err := m.Level.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SupportEmail != nil {
		{
			size, err := m.SupportEmail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Entries[iNdEx])
			copy(dAtA[i:], m.Entries[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.Entries[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockInterval != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x38
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExtraInfo) > 0 {
		i -= len(m.ExtraInfo)
		copy(dAtA[i:], m.ExtraInfo)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ExtraInfo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ItemOutputs != nil {
		{
			size, err := m.ItemOutputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CoinOutputs) > 0 {
		for iNdEx := len(m.CoinOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExecuteRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExecuteRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExecuteRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFiatItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFiatItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFiatItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Strings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Doubles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfillTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfillTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfillTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGetPylons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPylons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGetPylons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgGoogleIAPGetPylons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGoogleIAPGetPylons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGoogleIAPGetPylons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReceiptDataBase64) > 0 {
		i -= len(m.ReceiptDataBase64)
		copy(dAtA[i:], m.ReceiptDataBase64)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ReceiptDataBase64)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PurchaseToken) > 0 {
		i -= len(m.PurchaseToken)
		copy(dAtA[i:], m.PurchaseToken)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.PurchaseToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductID) > 0 {
		i -= len(m.ProductID)
		copy(dAtA[i:], m.ProductID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ProductID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendCoins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendCoins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateItemString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateItemString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateItemString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCookbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCookbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCookbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if m.SupportEmail != nil {
		{
			size, err := m.SupportEmail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Entries[iNdEx])
			copy(dAtA[i:], m.Entries[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.Entries[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockInterval != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x38
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgs(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCheckExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.PayToComplete {
		n += 2
	}
	return n
}

func (m *MsgCreateAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateCookbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.SupportEmail != nil {
		l = m.SupportEmail.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Level != nil {
		l = m.Level.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CostPerBlock != 0 {
		n += 1 + sovMsgs(uint64(m.CostPerBlock))
	}
	return n
}

func (m *MsgCreateRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovMsgs(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, b := range m.Entries {
			l = len(b)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.CoinOutputs) > 0 {
		for _, e := range m.CoinOutputs {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	if m.ItemOutputs != nil {
		l = m.ItemOutputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ExtraInfo)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgExecuteRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgFiatItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.Doubles) > 0 {
		for _, e := range m.Doubles {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, e := range m.Strings {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.TransferFee != 0 {
		n += 1 + sovMsgs(uint64(m.TransferFee))
	}
	return n
}

func (m *MsgFulfillTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgGetPylons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgGoogleIAPGetPylons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.PurchaseToken)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ReceiptDataBase64)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgSendCoins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgSendItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateItemString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateCookbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.SupportEmail != nil {
		l = m.SupportEmail.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovMsgs(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, b := range m.Entries {
			l = len(b)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func sovMsgs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgs(x uint64) (n int) {
	return sovMsgs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCheckExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCheckExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCheckExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayToComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayToComplete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCookbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCookbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCookbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &types.SemVer{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportEmail == nil {
				m.SupportEmail = &types.Email{}
			}
			if err := m.SupportEmail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Level == nil {
				m.Level = &types.Level{}
			}
			if err := m.Level.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostPerBlock", wireType)
			}
			m.CostPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.ItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &types.WeightedOutputsList{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, make([]byte, postIndex-iNdEx))
			copy(m.Entries[len(m.Entries)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.TradeItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinOutputs = append(m.CoinOutputs, types1.Coin{})
			if err := m.CoinOutputs[len(m.CoinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemOutputs == nil {
				m.ItemOutputs = &types.ItemList{}
			}
			if err := m.ItemOutputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExecuteRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExecuteRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExecuteRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFiatItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFiatItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFiatItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Doubles = append(m.Doubles, &types.DoubleKeyValue{})
			if err := m.Doubles[len(m.Doubles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, &types.LongKeyValue{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, &types.StringKeyValue{})
			if err := m.Strings[len(m.Strings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfillTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfillTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfillTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPylons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPylons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPylons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGoogleIAPGetPylons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchaseToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptDataBase64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptDataBase64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateItemString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateItemString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateItemString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCookbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCookbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCookbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &types.SemVer{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportEmail == nil {
				m.SupportEmail = &types.Email{}
			}
			if err := m.SupportEmail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.ItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &types.WeightedOutputsList{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, make([]byte, postIndex-iNdEx))
			copy(m.Entries[len(m.Entries)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgs = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pylons/msgs.proto

package msgs

import (
	context "context"
	fmt "fmt"
	types "github.com/Pylons-tech/pylons/x/pylons/types"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCheckExecution defines a CheckExecution message
type MsgCheckExecution struct {
	ExecID string `protobuf:"bytes,1,opt,name=ExecID,proto3" json:"ExecID,omitempty"`
	Sender string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	// if this is set to true then we complete the execution by paying for it
	PayToComplete bool `protobuf:"varint,3,opt,name=PayToComplete,proto3" json:"PayToComplete,omitempty"`
}

func (m *MsgCheckExecution) Reset()         { *m = MsgCheckExecution{} }
func (m *MsgCheckExecution) String() string { return proto.CompactTextString(m) }
func (*MsgCheckExecution) ProtoMessage()    {}
func (*MsgCheckExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{0}
}
func (m *MsgCheckExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCheckExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCheckExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCheckExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCheckExecution.Merge(m, src)
}
func (m *MsgCheckExecution) XXX_Size() int {
	return m.Size()
}
func (m *MsgCheckExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCheckExecution.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCheckExecution proto.InternalMessageInfo

func (m *MsgCheckExecution) GetExecID() string {
	if m != nil {
		return m.ExecID
	}
	return ""
}

func (m *MsgCheckExecution) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCheckExecution) GetPayToComplete() bool {
	if m != nil {
		return m.PayToComplete
	}
	return false
}

// CheckExecutionResponse is the response for checkExecution
type MsgCheckExecutionResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
	Output  []byte `protobuf:"bytes,3,opt,name=Output,proto3" json:"Output,omitempty"`
}

func (m *MsgCheckExecutionResponse) Reset()         { *m = MsgCheckExecutionResponse{} }
func (m *MsgCheckExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCheckExecutionResponse) ProtoMessage()    {}
func (*MsgCheckExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{1}
}
func (m *MsgCheckExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCheckExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCheckExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCheckExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCheckExecutionResponse.Merge(m, src)
}
func (m *MsgCheckExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCheckExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCheckExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCheckExecutionResponse proto.InternalMessageInfo

func (m *MsgCheckExecutionResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgCheckExecutionResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgCheckExecutionResponse) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

// MsgCreateAccount defines a CreateAccount message
type MsgCreateAccount struct {
	Requester string `protobuf:"bytes,1,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgCreateAccount) Reset()         { *m = MsgCreateAccount{} }
func (m *MsgCreateAccount) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAccount) ProtoMessage()    {}
func (*MsgCreateAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{2}
}
func (m *MsgCreateAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAccount.Merge(m, src)
}
func (m *MsgCreateAccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAccount proto.InternalMessageInfo

func (m *MsgCreateAccount) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// MsgCreateExecutionResponse is the response for create-account
type MsgCreateExecutionResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgCreateExecutionResponse) Reset()         { *m = MsgCreateExecutionResponse{} }
func (m *MsgCreateExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateExecutionResponse) ProtoMessage()    {}
func (*MsgCreateExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{3}
}
func (m *MsgCreateExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateExecutionResponse.Merge(m, src)
}
func (m *MsgCreateExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateExecutionResponse proto.InternalMessageInfo

func (m *MsgCreateExecutionResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgCreateExecutionResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

//Cookbook is a struct that contains all the metadata of a cookbook
type MsgCreateCookbook struct {
	// optinal id which can be provided by the developer
	CookbookID   string        `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Name         string        `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Description  string        `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      *types.SemVer `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string        `protobuf:"bytes,5,opt,name=Developer,proto3" json:"Developer,omitempty"`
	SupportEmail *types.Email  `protobuf:"bytes,6,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	Level        *types.Level  `protobuf:"bytes,7,opt,name=Level,proto3" json:"Level,omitempty"`
	Sender       string        `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	// Pylons per block to be charged across this cookbook for delayed execution early completion
	CostPerBlock int64 `protobuf:"varint,9,opt,name=CostPerBlock,proto3" json:"CostPerBlock,omitempty"`
}

func (m *MsgCreateCookbook) Reset()         { *m = MsgCreateCookbook{} }
func (m *MsgCreateCookbook) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCookbook) ProtoMessage()    {}
func (*MsgCreateCookbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{4}
}
func (m *MsgCreateCookbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCookbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCookbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCookbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCookbook.Merge(m, src)
}
func (m *MsgCreateCookbook) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCookbook) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCookbook.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCookbook proto.InternalMessageInfo

func (m *MsgCreateCookbook) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgCreateCookbook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateCookbook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateCookbook) GetVersion() *types.SemVer {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *MsgCreateCookbook) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *MsgCreateCookbook) GetSupportEmail() *types.Email {
	if m != nil {
		return m.SupportEmail
	}
	return nil
}

func (m *MsgCreateCookbook) GetLevel() *types.Level {
	if m != nil {
		return m.Level
	}
	return nil
}

func (m *MsgCreateCookbook) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreateCookbook) GetCostPerBlock() int64 {
	if m != nil {
		return m.CostPerBlock
	}
	return 0
}

// MsgCreateCookbookResponse is a struct of create cookbook response
type MsgCreateCookbookResponse struct {
	CookbookID string `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID"`
	Message    string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status     string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgCreateCookbookResponse) Reset()         { *m = MsgCreateCookbookResponse{} }
func (m *MsgCreateCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCookbookResponse) ProtoMessage()    {}
func (*MsgCreateCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{5}
}
func (m *MsgCreateCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCookbookResponse.Merge(m, src)
}
func (m *MsgCreateCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCookbookResponse proto.InternalMessageInfo

func (m *MsgCreateCookbookResponse) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgCreateCookbookResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgCreateCookbookResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgCreateRecipe defines a CreateRecipe message
type MsgCreateRecipe struct {
	// optional RecipeID if someone
	RecipeID      string                     `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Name          string                     `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	CookbookID    string                     `protobuf:"bytes,3,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	CoinInputs    *types.CoinInputList       `protobuf:"bytes,4,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs    *types.ItemInputList       `protobuf:"bytes,5,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	Outputs       *types.WeightedOutputsList `protobuf:"bytes,6,opt,name=Outputs,proto3" json:"Outputs,omitempty"`
	BlockInterval int64                      `protobuf:"varint,7,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string                     `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Description   string                     `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	Entries       *types.EntriesList         `protobuf:"bytes,10,opt,name=Entries,proto3" json:"Entries,omitempty"`
}

func (m *MsgCreateRecipe) Reset()         { *m = MsgCreateRecipe{} }
func (m *MsgCreateRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRecipe) ProtoMessage()    {}
func (*MsgCreateRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{6}
}
func (m *MsgCreateRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRecipe.Merge(m, src)
}
func (m *MsgCreateRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRecipe proto.InternalMessageInfo

func (m *MsgCreateRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgCreateRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateRecipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgCreateRecipe) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetItemInputs() *types.ItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetOutputs() *types.WeightedOutputsList {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *MsgCreateRecipe) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *MsgCreateRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreateRecipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateRecipe) GetEntries() *types.EntriesList {
	if m != nil {
		return m.Entries
	}
	return nil
}

// MsgCreateRecipeResponse is struct of create recipe response
type MsgCreateRecipeResponse struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID"`
	Message  string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status   string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgCreateRecipeResponse) Reset()         { *m = MsgCreateRecipeResponse{} }
func (m *MsgCreateRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRecipeResponse) ProtoMessage()    {}
func (*MsgCreateRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{7}
}
func (m *MsgCreateRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRecipeResponse.Merge(m, src)
}
func (m *MsgCreateRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRecipeResponse proto.InternalMessageInfo

func (m *MsgCreateRecipeResponse) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgCreateRecipeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgCreateRecipeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgCreateTrade defines a CreateTrade message
type MsgCreateTrade struct {
	CoinInputs  *types.CoinInputList                     `protobuf:"bytes,1,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs  *types.TradeItemInputList                `protobuf:"bytes,2,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	CoinOutputs github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=CoinOutputs,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"CoinOutputs"`
	ItemOutputs *types.ItemList                          `protobuf:"bytes,4,opt,name=ItemOutputs,proto3" json:"ItemOutputs,omitempty"`
	ExtraInfo   string                                   `protobuf:"bytes,5,opt,name=ExtraInfo,proto3" json:"ExtraInfo,omitempty"`
	Sender      string                                   `protobuf:"bytes,6,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgCreateTrade) Reset()         { *m = MsgCreateTrade{} }
func (m *MsgCreateTrade) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrade) ProtoMessage()    {}
func (*MsgCreateTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{8}
}
func (m *MsgCreateTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrade.Merge(m, src)
}
func (m *MsgCreateTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrade proto.InternalMessageInfo

func (m *MsgCreateTrade) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgCreateTrade) GetItemInputs() *types.TradeItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgCreateTrade) GetCoinOutputs() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CoinOutputs
	}
	return nil
}

func (m *MsgCreateTrade) GetItemOutputs() *types.ItemList {
	if m != nil {
		return m.ItemOutputs
	}
	return nil
}

func (m *MsgCreateTrade) GetExtraInfo() string {
	if m != nil {
		return m.ExtraInfo
	}
	return ""
}

func (m *MsgCreateTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgCreateTradeResponse is struct of create trade response
type MsgCreateTradeResponse struct {
	TradeID string `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgCreateTradeResponse) Reset()         { *m = MsgCreateTradeResponse{} }
func (m *MsgCreateTradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTradeResponse) ProtoMessage()    {}
func (*MsgCreateTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{9}
}
func (m *MsgCreateTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTradeResponse.Merge(m, src)
}
func (m *MsgCreateTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTradeResponse proto.InternalMessageInfo

func (m *MsgCreateTradeResponse) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgCreateTradeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgCreateTradeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgDisableRecipe defines a DisableRecipe message
type MsgDisableRecipe struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgDisableRecipe) Reset()         { *m = MsgDisableRecipe{} }
func (m *MsgDisableRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgDisableRecipe) ProtoMessage()    {}
func (*MsgDisableRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{10}
}
func (m *MsgDisableRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableRecipe.Merge(m, src)
}
func (m *MsgDisableRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableRecipe proto.InternalMessageInfo

func (m *MsgDisableRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgDisableRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// DisableRecipeResponse is the response for disableRecipe
type MsgDisableRecipeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgDisableRecipeResponse) Reset()         { *m = MsgDisableRecipeResponse{} }
func (m *MsgDisableRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisableRecipeResponse) ProtoMessage()    {}
func (*MsgDisableRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{11}
}
func (m *MsgDisableRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableRecipeResponse.Merge(m, src)
}
func (m *MsgDisableRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableRecipeResponse proto.InternalMessageInfo

func (m *MsgDisableRecipeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgDisableRecipeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgDisableTrade defines a DisableTrade message
type MsgDisableTrade struct {
	TradeID string `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgDisableTrade) Reset()         { *m = MsgDisableTrade{} }
func (m *MsgDisableTrade) String() string { return proto.CompactTextString(m) }
func (*MsgDisableTrade) ProtoMessage()    {}
func (*MsgDisableTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{12}
}
func (m *MsgDisableTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableTrade.Merge(m, src)
}
func (m *MsgDisableTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableTrade proto.InternalMessageInfo

func (m *MsgDisableTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgDisableTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgDisableTradeResponse is the response for enableTrade
type MsgDisableTradeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgDisableTradeResponse) Reset()         { *m = MsgDisableTradeResponse{} }
func (m *MsgDisableTradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisableTradeResponse) ProtoMessage()    {}
func (*MsgDisableTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{13}
}
func (m *MsgDisableTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableTradeResponse.Merge(m, src)
}
func (m *MsgDisableTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableTradeResponse proto.InternalMessageInfo

func (m *MsgDisableTradeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgDisableTradeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgEnableRecipe defines a EnableRecipe message
type MsgEnableRecipe struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgEnableRecipe) Reset()         { *m = MsgEnableRecipe{} }
func (m *MsgEnableRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgEnableRecipe) ProtoMessage()    {}
func (*MsgEnableRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{14}
}
func (m *MsgEnableRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableRecipe.Merge(m, src)
}
func (m *MsgEnableRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableRecipe proto.InternalMessageInfo

func (m *MsgEnableRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgEnableRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgEnableRecipeResponse is the response for enableRecipe
type MsgEnableRecipeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgEnableRecipeResponse) Reset()         { *m = MsgEnableRecipeResponse{} }
func (m *MsgEnableRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEnableRecipeResponse) ProtoMessage()    {}
func (*MsgEnableRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{15}
}
func (m *MsgEnableRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableRecipeResponse.Merge(m, src)
}
func (m *MsgEnableRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableRecipeResponse proto.InternalMessageInfo

func (m *MsgEnableRecipeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgEnableRecipeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgEnableTrade defines a EnableTrade message
type MsgEnableTrade struct {
	TradeID string `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgEnableTrade) Reset()         { *m = MsgEnableTrade{} }
func (m *MsgEnableTrade) String() string { return proto.CompactTextString(m) }
func (*MsgEnableTrade) ProtoMessage()    {}
func (*MsgEnableTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{16}
}
func (m *MsgEnableTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableTrade.Merge(m, src)
}
func (m *MsgEnableTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableTrade proto.InternalMessageInfo

func (m *MsgEnableTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgEnableTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgEnableTradeResponse is the response for enableTrade
type MsgEnableTradeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgEnableTradeResponse) Reset()         { *m = MsgEnableTradeResponse{} }
func (m *MsgEnableTradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEnableTradeResponse) ProtoMessage()    {}
func (*MsgEnableTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{17}
}
func (m *MsgEnableTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEnableTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEnableTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEnableTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEnableTradeResponse.Merge(m, src)
}
func (m *MsgEnableTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEnableTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEnableTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEnableTradeResponse proto.InternalMessageInfo

func (m *MsgEnableTradeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgEnableTradeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgExecuteRecipe defines a SetName message
type MsgExecuteRecipe struct {
	RecipeID string   `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID,omitempty"`
	Sender   string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemIDs  []string `protobuf:"bytes,3,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
}

func (m *MsgExecuteRecipe) Reset()         { *m = MsgExecuteRecipe{} }
func (m *MsgExecuteRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgExecuteRecipe) ProtoMessage()    {}
func (*MsgExecuteRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{18}
}
func (m *MsgExecuteRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExecuteRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExecuteRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExecuteRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExecuteRecipe.Merge(m, src)
}
func (m *MsgExecuteRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgExecuteRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExecuteRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExecuteRecipe proto.InternalMessageInfo

func (m *MsgExecuteRecipe) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgExecuteRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgExecuteRecipe) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

// ExecuteRecipeResponse is the response for executeRecipe
type MsgExecuteRecipeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
	Output  []byte `protobuf:"bytes,3,opt,name=Output,proto3" json:"Output,omitempty"`
}

func (m *MsgExecuteRecipeResponse) Reset()         { *m = MsgExecuteRecipeResponse{} }
func (m *MsgExecuteRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgExecuteRecipeResponse) ProtoMessage()    {}
func (*MsgExecuteRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{19}
}
func (m *MsgExecuteRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExecuteRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExecuteRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExecuteRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExecuteRecipeResponse.Merge(m, src)
}
func (m *MsgExecuteRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgExecuteRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExecuteRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExecuteRecipeResponse proto.InternalMessageInfo

func (m *MsgExecuteRecipeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgExecuteRecipeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgExecuteRecipeResponse) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

// MsgFiatItem is a msg struct to be used to fiat item
type MsgFiatItem struct {
	CookbookID  string                    `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	Doubles     *types.DoubleKeyValueList `protobuf:"bytes,2,opt,name=Doubles,proto3" json:"Doubles,omitempty"`
	Longs       *types.LongKeyValueList   `protobuf:"bytes,3,opt,name=Longs,proto3" json:"Longs,omitempty"`
	Strings     *types.StringKeyValueList `protobuf:"bytes,4,opt,name=Strings,proto3" json:"Strings,omitempty"`
	Sender      string                    `protobuf:"bytes,5,opt,name=Sender,proto3" json:"Sender,omitempty"`
	TransferFee int64                     `protobuf:"varint,6,opt,name=TransferFee,proto3" json:"TransferFee,omitempty"`
}

func (m *MsgFiatItem) Reset()         { *m = MsgFiatItem{} }
func (m *MsgFiatItem) String() string { return proto.CompactTextString(m) }
func (*MsgFiatItem) ProtoMessage()    {}
func (*MsgFiatItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{20}
}
func (m *MsgFiatItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFiatItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFiatItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFiatItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFiatItem.Merge(m, src)
}
func (m *MsgFiatItem) XXX_Size() int {
	return m.Size()
}
func (m *MsgFiatItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFiatItem.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFiatItem proto.InternalMessageInfo

func (m *MsgFiatItem) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgFiatItem) GetDoubles() *types.DoubleKeyValueList {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *MsgFiatItem) GetLongs() *types.LongKeyValueList {
	if m != nil {
		return m.Longs
	}
	return nil
}

func (m *MsgFiatItem) GetStrings() *types.StringKeyValueList {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *MsgFiatItem) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgFiatItem) GetTransferFee() int64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

// MsgFiatItemResponse is a struct to control fiat item response
type MsgFiatItemResponse struct {
	ItemID  string `protobuf:"bytes,1,opt,name=ItemID,proto3" json:"ItemID"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgFiatItemResponse) Reset()         { *m = MsgFiatItemResponse{} }
func (m *MsgFiatItemResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFiatItemResponse) ProtoMessage()    {}
func (*MsgFiatItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{21}
}
func (m *MsgFiatItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFiatItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFiatItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFiatItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFiatItemResponse.Merge(m, src)
}
func (m *MsgFiatItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFiatItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFiatItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFiatItemResponse proto.InternalMessageInfo

func (m *MsgFiatItemResponse) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

func (m *MsgFiatItemResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgFiatItemResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgFulfillTrade defines a FulfillTrade message
type MsgFulfillTrade struct {
	TradeID string   `protobuf:"bytes,1,opt,name=TradeID,proto3" json:"TradeID,omitempty"`
	Sender  string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemIDs []string `protobuf:"bytes,3,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
}

func (m *MsgFulfillTrade) Reset()         { *m = MsgFulfillTrade{} }
func (m *MsgFulfillTrade) String() string { return proto.CompactTextString(m) }
func (*MsgFulfillTrade) ProtoMessage()    {}
func (*MsgFulfillTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{22}
}
func (m *MsgFulfillTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfillTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfillTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfillTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfillTrade.Merge(m, src)
}
func (m *MsgFulfillTrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfillTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfillTrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfillTrade proto.InternalMessageInfo

func (m *MsgFulfillTrade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *MsgFulfillTrade) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgFulfillTrade) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

// FulfillTradeResponse is the response for fulfillRecipe
type MsgFulfillTradeResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgFulfillTradeResponse) Reset()         { *m = MsgFulfillTradeResponse{} }
func (m *MsgFulfillTradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFulfillTradeResponse) ProtoMessage()    {}
func (*MsgFulfillTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{23}
}
func (m *MsgFulfillTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfillTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfillTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfillTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfillTradeResponse.Merge(m, src)
}
func (m *MsgFulfillTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfillTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfillTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfillTradeResponse proto.InternalMessageInfo

func (m *MsgFulfillTradeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgFulfillTradeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgGetPylons defines a GetPylons message
type MsgGetPylons struct {
	Amount    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
	Requester string                                   `protobuf:"bytes,2,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgGetPylons) Reset()         { *m = MsgGetPylons{} }
func (m *MsgGetPylons) String() string { return proto.CompactTextString(m) }
func (*MsgGetPylons) ProtoMessage()    {}
func (*MsgGetPylons) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{24}
}
func (m *MsgGetPylons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGetPylons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGetPylons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGetPylons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGetPylons.Merge(m, src)
}
func (m *MsgGetPylons) XXX_Size() int {
	return m.Size()
}
func (m *MsgGetPylons) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGetPylons.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGetPylons proto.InternalMessageInfo

func (m *MsgGetPylons) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgGetPylons) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// MsgGetPylonsResponse is the response for get-pylons
type MsgGetPylonsResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgGetPylonsResponse) Reset()         { *m = MsgGetPylonsResponse{} }
func (m *MsgGetPylonsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgGetPylonsResponse) ProtoMessage()    {}
func (*MsgGetPylonsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{25}
}
func (m *MsgGetPylonsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGetPylonsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGetPylonsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGetPylonsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGetPylonsResponse.Merge(m, src)
}
func (m *MsgGetPylonsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgGetPylonsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGetPylonsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGetPylonsResponse proto.InternalMessageInfo

func (m *MsgGetPylonsResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgGetPylonsResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgGoogleIAPGetPylons defines a GetPylons message
type MsgGoogleIAPGetPylons struct {
	ProductID         string `protobuf:"bytes,1,opt,name=ProductID,proto3" json:"ProductID,omitempty"`
	PurchaseToken     string `protobuf:"bytes,2,opt,name=PurchaseToken,proto3" json:"PurchaseToken,omitempty"`
	ReceiptDataBase64 string `protobuf:"bytes,3,opt,name=ReceiptDataBase64,proto3" json:"ReceiptDataBase64,omitempty"`
	Signature         string `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	Requester         string `protobuf:"bytes,5,opt,name=Requester,proto3" json:"Requester,omitempty"`
}

func (m *MsgGoogleIAPGetPylons) Reset()         { *m = MsgGoogleIAPGetPylons{} }
func (m *MsgGoogleIAPGetPylons) String() string { return proto.CompactTextString(m) }
func (*MsgGoogleIAPGetPylons) ProtoMessage()    {}
func (*MsgGoogleIAPGetPylons) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{26}
}
func (m *MsgGoogleIAPGetPylons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGoogleIAPGetPylons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGoogleIAPGetPylons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGoogleIAPGetPylons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGoogleIAPGetPylons.Merge(m, src)
}
func (m *MsgGoogleIAPGetPylons) XXX_Size() int {
	return m.Size()
}
func (m *MsgGoogleIAPGetPylons) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGoogleIAPGetPylons.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGoogleIAPGetPylons proto.InternalMessageInfo

func (m *MsgGoogleIAPGetPylons) GetProductID() string {
	if m != nil {
		return m.ProductID
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetPurchaseToken() string {
	if m != nil {
		return m.PurchaseToken
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetReceiptDataBase64() string {
	if m != nil {
		return m.ReceiptDataBase64
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *MsgGoogleIAPGetPylons) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// MsgGoogleIAPGetPylonsResponse is the response for get-pylons
type MsgGoogleIAPGetPylonsResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgGoogleIAPGetPylonsResponse) Reset()         { *m = MsgGoogleIAPGetPylonsResponse{} }
func (m *MsgGoogleIAPGetPylonsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgGoogleIAPGetPylonsResponse) ProtoMessage()    {}
func (*MsgGoogleIAPGetPylonsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{27}
}
func (m *MsgGoogleIAPGetPylonsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGoogleIAPGetPylonsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGoogleIAPGetPylonsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGoogleIAPGetPylonsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGoogleIAPGetPylonsResponse.Merge(m, src)
}
func (m *MsgGoogleIAPGetPylonsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgGoogleIAPGetPylonsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGoogleIAPGetPylonsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGoogleIAPGetPylonsResponse proto.InternalMessageInfo

func (m *MsgGoogleIAPGetPylonsResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgGoogleIAPGetPylonsResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgSendCoins defines a SendCoins message
type MsgSendCoins struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=Amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"Amount"`
	Sender   string                                   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Receiver string                                   `protobuf:"bytes,3,opt,name=Receiver,proto3" json:"Receiver,omitempty"`
}

func (m *MsgSendCoins) Reset()         { *m = MsgSendCoins{} }
func (m *MsgSendCoins) String() string { return proto.CompactTextString(m) }
func (*MsgSendCoins) ProtoMessage()    {}
func (*MsgSendCoins) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{28}
}
func (m *MsgSendCoins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendCoins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendCoins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendCoins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendCoins.Merge(m, src)
}
func (m *MsgSendCoins) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendCoins) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendCoins.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendCoins proto.InternalMessageInfo

func (m *MsgSendCoins) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgSendCoins) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSendCoins) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

type MsgSendCoinsResponse struct {
}

func (m *MsgSendCoinsResponse) Reset()         { *m = MsgSendCoinsResponse{} }
func (m *MsgSendCoinsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendCoinsResponse) ProtoMessage()    {}
func (*MsgSendCoinsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{29}
}
func (m *MsgSendCoinsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendCoinsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendCoinsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendCoinsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendCoinsResponse.Merge(m, src)
}
func (m *MsgSendCoinsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendCoinsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendCoinsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendCoinsResponse proto.InternalMessageInfo

// MsgSendItems defines a SendItems message
type MsgSendItems struct {
	ItemIDs  []string `protobuf:"bytes,1,rep,name=ItemIDs,proto3" json:"ItemIDs,omitempty"`
	Sender   string   `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Receiver string   `protobuf:"bytes,3,opt,name=Receiver,proto3" json:"Receiver,omitempty"`
}

func (m *MsgSendItems) Reset()         { *m = MsgSendItems{} }
func (m *MsgSendItems) String() string { return proto.CompactTextString(m) }
func (*MsgSendItems) ProtoMessage()    {}
func (*MsgSendItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{30}
}
func (m *MsgSendItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendItems.Merge(m, src)
}
func (m *MsgSendItems) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendItems) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendItems.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendItems proto.InternalMessageInfo

func (m *MsgSendItems) GetItemIDs() []string {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

func (m *MsgSendItems) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSendItems) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// MsgSendItemsResponse is the response for fulfillRecipe
type MsgSendItemsResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgSendItemsResponse) Reset()         { *m = MsgSendItemsResponse{} }
func (m *MsgSendItemsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendItemsResponse) ProtoMessage()    {}
func (*MsgSendItemsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{31}
}
func (m *MsgSendItemsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendItemsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendItemsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendItemsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendItemsResponse.Merge(m, src)
}
func (m *MsgSendItemsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendItemsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendItemsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendItemsResponse proto.InternalMessageInfo

func (m *MsgSendItemsResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgSendItemsResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgUpdateItemString defines a UpdateItemString message
type MsgUpdateItemString struct {
	Field  string `protobuf:"bytes,1,opt,name=Field,proto3" json:"Field,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	Sender string `protobuf:"bytes,3,opt,name=Sender,proto3" json:"Sender,omitempty"`
	ItemID string `protobuf:"bytes,4,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
}

func (m *MsgUpdateItemString) Reset()         { *m = MsgUpdateItemString{} }
func (m *MsgUpdateItemString) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateItemString) ProtoMessage()    {}
func (*MsgUpdateItemString) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{32}
}
func (m *MsgUpdateItemString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateItemString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateItemString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateItemString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateItemString.Merge(m, src)
}
func (m *MsgUpdateItemString) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateItemString) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateItemString.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateItemString proto.InternalMessageInfo

func (m *MsgUpdateItemString) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *MsgUpdateItemString) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MsgUpdateItemString) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgUpdateItemString) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

// MsgUpdateItemStringResponse is a struct to control update item string response
type MsgUpdateItemStringResponse struct {
	Status  string `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *MsgUpdateItemStringResponse) Reset()         { *m = MsgUpdateItemStringResponse{} }
func (m *MsgUpdateItemStringResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateItemStringResponse) ProtoMessage()    {}
func (*MsgUpdateItemStringResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{33}
}
func (m *MsgUpdateItemStringResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateItemStringResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateItemStringResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateItemStringResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateItemStringResponse.Merge(m, src)
}
func (m *MsgUpdateItemStringResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateItemStringResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateItemStringResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateItemStringResponse proto.InternalMessageInfo

func (m *MsgUpdateItemStringResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgUpdateItemStringResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// MsgUpdateCookbook defines a UpdateCookbook message
type MsgUpdateCookbook struct {
	ID           string        `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Description  string        `protobuf:"bytes,2,opt,name=Description,proto3" json:"Description,omitempty"`
	Version      *types.SemVer `protobuf:"bytes,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Developer    string        `protobuf:"bytes,4,opt,name=Developer,proto3" json:"Developer,omitempty"`
	SupportEmail *types.Email  `protobuf:"bytes,5,opt,name=SupportEmail,proto3" json:"SupportEmail,omitempty"`
	Sender       string        `protobuf:"bytes,6,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *MsgUpdateCookbook) Reset()         { *m = MsgUpdateCookbook{} }
func (m *MsgUpdateCookbook) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCookbook) ProtoMessage()    {}
func (*MsgUpdateCookbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{34}
}
func (m *MsgUpdateCookbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCookbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCookbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCookbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCookbook.Merge(m, src)
}
func (m *MsgUpdateCookbook) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCookbook) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCookbook.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCookbook proto.InternalMessageInfo

func (m *MsgUpdateCookbook) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MsgUpdateCookbook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgUpdateCookbook) GetVersion() *types.SemVer {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *MsgUpdateCookbook) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *MsgUpdateCookbook) GetSupportEmail() *types.Email {
	if m != nil {
		return m.SupportEmail
	}
	return nil
}

func (m *MsgUpdateCookbook) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgUpdateCookbookResponse is a struct to control update cookbook response
type MsgUpdateCookbookResponse struct {
	CookbookID string `protobuf:"bytes,1,opt,name=CookbookID,proto3" json:"CookbookID"`
	Message    string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status     string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgUpdateCookbookResponse) Reset()         { *m = MsgUpdateCookbookResponse{} }
func (m *MsgUpdateCookbookResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCookbookResponse) ProtoMessage()    {}
func (*MsgUpdateCookbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{35}
}
func (m *MsgUpdateCookbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCookbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCookbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCookbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCookbookResponse.Merge(m, src)
}
func (m *MsgUpdateCookbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCookbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCookbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCookbookResponse proto.InternalMessageInfo

func (m *MsgUpdateCookbookResponse) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgUpdateCookbookResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgUpdateCookbookResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// MsgUpdateRecipe defines a UpdateRecipe message
type MsgUpdateRecipe struct {
	Name          string                     `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	CookbookID    string                     `protobuf:"bytes,2,opt,name=CookbookID,proto3" json:"CookbookID,omitempty"`
	ID            string                     `protobuf:"bytes,3,opt,name=ID,proto3" json:"ID,omitempty"`
	CoinInputs    *types.CoinInputList       `protobuf:"bytes,4,opt,name=CoinInputs,proto3" json:"CoinInputs,omitempty"`
	ItemInputs    *types.ItemInputList       `protobuf:"bytes,5,opt,name=ItemInputs,proto3" json:"ItemInputs,omitempty"`
	Outputs       *types.WeightedOutputsList `protobuf:"bytes,6,opt,name=Outputs,proto3" json:"Outputs,omitempty"`
	BlockInterval int64                      `protobuf:"varint,7,opt,name=BlockInterval,proto3" json:"BlockInterval,omitempty"`
	Sender        string                     `protobuf:"bytes,8,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Description   string                     `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	Entries       *types.EntriesList         `protobuf:"bytes,10,opt,name=Entries,proto3" json:"Entries,omitempty"`
}

func (m *MsgUpdateRecipe) Reset()         { *m = MsgUpdateRecipe{} }
func (m *MsgUpdateRecipe) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRecipe) ProtoMessage()    {}
func (*MsgUpdateRecipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{36}
}
func (m *MsgUpdateRecipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRecipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRecipe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRecipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRecipe.Merge(m, src)
}
func (m *MsgUpdateRecipe) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRecipe) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRecipe.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRecipe proto.InternalMessageInfo

func (m *MsgUpdateRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateRecipe) GetCookbookID() string {
	if m != nil {
		return m.CookbookID
	}
	return ""
}

func (m *MsgUpdateRecipe) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MsgUpdateRecipe) GetCoinInputs() *types.CoinInputList {
	if m != nil {
		return m.CoinInputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetItemInputs() *types.ItemInputList {
	if m != nil {
		return m.ItemInputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetOutputs() *types.WeightedOutputsList {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *MsgUpdateRecipe) GetBlockInterval() int64 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *MsgUpdateRecipe) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgUpdateRecipe) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgUpdateRecipe) GetEntries() *types.EntriesList {
	if m != nil {
		return m.Entries
	}
	return nil
}

// UpdateRecipeResponse is a struct to control update recipe response
type MsgUpdateRecipeResponse struct {
	RecipeID string `protobuf:"bytes,1,opt,name=RecipeID,proto3" json:"RecipeID"`
	Message  string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Status   string `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MsgUpdateRecipeResponse) Reset()         { *m = MsgUpdateRecipeResponse{} }
func (m *MsgUpdateRecipeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRecipeResponse) ProtoMessage()    {}
func (*MsgUpdateRecipeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c904270567374406, []int{37}
}
func (m *MsgUpdateRecipeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRecipeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRecipeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRecipeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRecipeResponse.Merge(m, src)
}
func (m *MsgUpdateRecipeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRecipeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRecipeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRecipeResponse proto.InternalMessageInfo

func (m *MsgUpdateRecipeResponse) GetRecipeID() string {
	if m != nil {
		return m.RecipeID
	}
	return ""
}

func (m *MsgUpdateRecipeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MsgUpdateRecipeResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgCheckExecution)(nil), "pylons.MsgCheckExecution")
	proto.RegisterType((*MsgCheckExecutionResponse)(nil), "pylons.MsgCheckExecutionResponse")
	proto.RegisterType((*MsgCreateAccount)(nil), "pylons.MsgCreateAccount")
	proto.RegisterType((*MsgCreateExecutionResponse)(nil), "pylons.MsgCreateExecutionResponse")
	proto.RegisterType((*MsgCreateCookbook)(nil), "pylons.MsgCreateCookbook")
	proto.RegisterType((*MsgCreateCookbookResponse)(nil), "pylons.MsgCreateCookbookResponse")
	proto.RegisterType((*MsgCreateRecipe)(nil), "pylons.MsgCreateRecipe")
	proto.RegisterType((*MsgCreateRecipeResponse)(nil), "pylons.MsgCreateRecipeResponse")
	proto.RegisterType((*MsgCreateTrade)(nil), "pylons.MsgCreateTrade")
	proto.RegisterType((*MsgCreateTradeResponse)(nil), "pylons.MsgCreateTradeResponse")
	proto.RegisterType((*MsgDisableRecipe)(nil), "pylons.MsgDisableRecipe")
	proto.RegisterType((*MsgDisableRecipeResponse)(nil), "pylons.MsgDisableRecipeResponse")
	proto.RegisterType((*MsgDisableTrade)(nil), "pylons.MsgDisableTrade")
	proto.RegisterType((*MsgDisableTradeResponse)(nil), "pylons.MsgDisableTradeResponse")
	proto.RegisterType((*MsgEnableRecipe)(nil), "pylons.MsgEnableRecipe")
	proto.RegisterType((*MsgEnableRecipeResponse)(nil), "pylons.MsgEnableRecipeResponse")
	proto.RegisterType((*MsgEnableTrade)(nil), "pylons.MsgEnableTrade")
	proto.RegisterType((*MsgEnableTradeResponse)(nil), "pylons.MsgEnableTradeResponse")
	proto.RegisterType((*MsgExecuteRecipe)(nil), "pylons.MsgExecuteRecipe")
	proto.RegisterType((*MsgExecuteRecipeResponse)(nil), "pylons.MsgExecuteRecipeResponse")
	proto.RegisterType((*MsgFiatItem)(nil), "pylons.MsgFiatItem")
	proto.RegisterType((*MsgFiatItemResponse)(nil), "pylons.MsgFiatItemResponse")
	proto.RegisterType((*MsgFulfillTrade)(nil), "pylons.MsgFulfillTrade")
	proto.RegisterType((*MsgFulfillTradeResponse)(nil), "pylons.MsgFulfillTradeResponse")
	proto.RegisterType((*MsgGetPylons)(nil), "pylons.MsgGetPylons")
	proto.RegisterType((*MsgGetPylonsResponse)(nil), "pylons.MsgGetPylonsResponse")
	proto.RegisterType((*MsgGoogleIAPGetPylons)(nil), "pylons.MsgGoogleIAPGetPylons")
	proto.RegisterType((*MsgGoogleIAPGetPylonsResponse)(nil), "pylons.MsgGoogleIAPGetPylonsResponse")
	proto.RegisterType((*MsgSendCoins)(nil), "pylons.MsgSendCoins")
	proto.RegisterType((*MsgSendCoinsResponse)(nil), "pylons.MsgSendCoinsResponse")
	proto.RegisterType((*MsgSendItems)(nil), "pylons.MsgSendItems")
	proto.RegisterType((*MsgSendItemsResponse)(nil), "pylons.MsgSendItemsResponse")
	proto.RegisterType((*MsgUpdateItemString)(nil), "pylons.MsgUpdateItemString")
	proto.RegisterType((*MsgUpdateItemStringResponse)(nil), "pylons.MsgUpdateItemStringResponse")
	proto.RegisterType((*MsgUpdateCookbook)(nil), "pylons.MsgUpdateCookbook")
	proto.RegisterType((*MsgUpdateCookbookResponse)(nil), "pylons.MsgUpdateCookbookResponse")
	proto.RegisterType((*MsgUpdateRecipe)(nil), "pylons.MsgUpdateRecipe")
	proto.RegisterType((*MsgUpdateRecipeResponse)(nil), "pylons.MsgUpdateRecipeResponse")
}

func init() { proto.RegisterFile("pylons/msgs.proto", fileDescriptor_c904270567374406) }

var fileDescriptor_c904270567374406 = []byte{
	// 1727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x41, 0x73, 0xdb, 0xb6,
	0x12, 0x36, 0x25, 0xcb, 0x8e, 0x20, 0xc7, 0x2f, 0xa1, 0x1d, 0x5b, 0xa6, 0x1d, 0xd9, 0x8f, 0x79,
	0x99, 0xd1, 0xcc, 0x7b, 0x91, 0x12, 0xbf, 0xa4, 0x87, 0xde, 0x62, 0xcb, 0x6e, 0xd4, 0xd8, 0x89,
	0x4b, 0x3b, 0x49, 0xa7, 0xd3, 0x76, 0x4a, 0x51, 0x30, 0xcd, 0xb1, 0x44, 0x30, 0x04, 0xe8, 0x89,
	0x0f, 0x3d, 0xf5, 0xd4, 0x5b, 0x7b, 0xe8, 0x6f, 0xe8, 0x4c, 0xff, 0x47, 0x67, 0x72, 0x6b, 0x8e,
	0x39, 0x74, 0xdc, 0x4e, 0x72, 0xf3, 0xaf, 0xe8, 0x10, 0x00, 0x21, 0x80, 0xa4, 0x9c, 0xc4, 0x4a,
	0x73, 0xea, 0xc9, 0xc2, 0x2e, 0xf0, 0xed, 0x62, 0xbf, 0xc5, 0x02, 0x4b, 0x83, 0xcb, 0xc1, 0x71,
	0x0f, 0xf9, 0xb8, 0xd9, 0xc7, 0x2e, 0x6e, 0x04, 0x21, 0x22, 0x48, 0x9f, 0x60, 0x22, 0x63, 0xd6,
	0x45, 0x2e, 0xa2, 0xa2, 0x66, 0xfc, 0x8b, 0x69, 0x8d, 0x05, 0x17, 0x21, 0xb7, 0x07, 0x9b, 0x74,
	0xd4, 0x89, 0xf6, 0x9b, 0xb6, 0x7f, 0xcc, 0x55, 0x4b, 0x5c, 0x65, 0x07, 0x5e, 0xd3, 0xf6, 0x7d,
	0x44, 0x6c, 0xe2, 0x21, 0x9f, 0xc3, 0x1a, 0x35, 0x07, 0xe1, 0x3e, 0xc2, 0xcd, 0x8e, 0x8d, 0x61,
	0xf3, 0xe8, 0x56, 0x07, 0x12, 0xfb, 0x56, 0xd3, 0x41, 0x9e, 0xcf, 0xf5, 0xd7, 0x64, 0xbd, 0xdd,
	0x71, 0x3c, 0x31, 0x29, 0x1e, 0xf0, 0x49, 0x3a, 0x77, 0x97, 0x1c, 0x07, 0x90, 0x03, 0x9b, 0x1e,
	0xb8, 0xbc, 0x8d, 0xdd, 0xf5, 0x03, 0xe8, 0x1c, 0x6e, 0x3c, 0x83, 0x4e, 0x14, 0x1b, 0xd5, 0xe7,
	0xc0, 0x44, 0x3c, 0x68, 0xb7, 0xaa, 0xda, 0x8a, 0x56, 0x2f, 0x5b, 0x7c, 0x14, 0xcb, 0x77, 0xa1,
	0xdf, 0x85, 0x61, 0xb5, 0xc0, 0xe4, 0x6c, 0xa4, 0xff, 0x07, 0x5c, 0xdc, 0xb1, 0x8f, 0xf7, 0xd0,
	0x3a, 0xea, 0x07, 0x3d, 0x48, 0x60, 0xb5, 0xb8, 0xa2, 0xd5, 0x2f, 0x58, 0xaa, 0xd0, 0x84, 0x60,
	0x21, 0x63, 0xca, 0x82, 0x38, 0x40, 0x3e, 0x86, 0x7a, 0x15, 0x4c, 0x6e, 0x43, 0x8c, 0x6d, 0x17,
	0x72, 0x9b, 0xc9, 0x90, 0x1a, 0x25, 0x36, 0x89, 0xb0, 0x30, 0x4a, 0x47, 0xb1, 0xfc, 0x61, 0x44,
	0x82, 0x88, 0x50, 0x6b, 0x53, 0x16, 0x1f, 0x99, 0x37, 0xc1, 0xa5, 0xd8, 0x4c, 0x08, 0x6d, 0x02,
	0xef, 0x3a, 0x0e, 0x8a, 0x7c, 0xa2, 0x2f, 0x81, 0xb2, 0x05, 0x9f, 0x46, 0x10, 0x13, 0x18, 0x72,
	0xfc, 0x81, 0xc0, 0x7c, 0x00, 0x0c, 0xb1, 0xe2, 0x3d, 0x78, 0x66, 0xfe, 0x5a, 0x60, 0x41, 0xa5,
	0x80, 0xeb, 0x08, 0x1d, 0x76, 0x10, 0x3a, 0xd4, 0x6b, 0x00, 0x24, 0xbf, 0x45, 0x60, 0x25, 0x89,
	0xae, 0x83, 0xf1, 0x07, 0x76, 0x1f, 0x72, 0x2c, 0xfa, 0x5b, 0x5f, 0x01, 0x95, 0x16, 0xc4, 0x4e,
	0xe8, 0x05, 0xb1, 0x4b, 0x74, 0xa3, 0x65, 0x4b, 0x16, 0xe9, 0x75, 0x30, 0xf9, 0x18, 0x86, 0x38,
	0xd6, 0x8e, 0xaf, 0x68, 0xf5, 0xca, 0xea, 0x74, 0x83, 0xb1, 0xdc, 0xd8, 0x85, 0xfd, 0xc7, 0x30,
	0xb4, 0x12, 0x75, 0x1c, 0x83, 0x16, 0x3c, 0x82, 0x3d, 0x14, 0xc0, 0xb0, 0x5a, 0x62, 0x31, 0x10,
	0x02, 0xfd, 0x16, 0x98, 0xda, 0x8d, 0x82, 0x00, 0x85, 0x64, 0xa3, 0x6f, 0x7b, 0xbd, 0xea, 0x04,
	0x05, 0xbb, 0x98, 0x80, 0x51, 0xa1, 0xa5, 0x4c, 0xd1, 0xaf, 0x81, 0xd2, 0x56, 0xbc, 0xbe, 0x3a,
	0xa9, 0xce, 0xa5, 0x42, 0x8b, 0xe9, 0xa4, 0x94, 0xb9, 0xa0, 0xa4, 0x8c, 0x09, 0xa6, 0xd6, 0x11,
	0x26, 0x3b, 0x30, 0x5c, 0xeb, 0x21, 0xe7, 0xb0, 0x5a, 0x5e, 0xd1, 0xea, 0x45, 0x4b, 0x91, 0x99,
	0xdf, 0xb2, 0x84, 0x51, 0xc2, 0x28, 0x68, 0x69, 0x64, 0xc3, 0xb9, 0x36, 0x7d, 0x7a, 0xb2, 0x2c,
	0x49, 0x95, 0xf0, 0x4a, 0x34, 0x16, 0x86, 0xd1, 0x58, 0x54, 0x68, 0xfc, 0xa9, 0x08, 0xfe, 0x25,
	0xec, 0x5b, 0xd0, 0xf1, 0x02, 0xa8, 0x1b, 0xe0, 0x02, 0xfb, 0x25, 0x28, 0x14, 0xe3, 0x5c, 0x02,
	0x55, 0xd2, 0x8b, 0x19, 0xd2, 0xef, 0xc4, 0x7a, 0xcf, 0x6f, 0xfb, 0x41, 0x44, 0x30, 0x67, 0xf0,
	0x4a, 0x12, 0x48, 0xa1, 0xd9, 0xf2, 0x30, 0xb1, 0xa4, 0x89, 0xf1, 0xb2, 0x36, 0x81, 0x7d, 0xbe,
	0xac, 0xa4, 0x2e, 0x13, 0x1a, 0xb6, 0x6c, 0x30, 0x51, 0xbf, 0x03, 0x26, 0xd9, 0x21, 0xc1, 0x9c,
	0xdf, 0xc5, 0x64, 0xcd, 0x13, 0xe8, 0xb9, 0x07, 0x04, 0x76, 0xb9, 0x9a, 0xae, 0x4c, 0xe6, 0xc6,
	0xc7, 0x9b, 0x12, 0xd2, 0xf6, 0x09, 0x0c, 0x8f, 0x6c, 0x46, 0x78, 0xd1, 0x52, 0x85, 0x43, 0x99,
	0x4e, 0xe5, 0x70, 0x39, 0x9b, 0xc3, 0x37, 0xc0, 0xe4, 0x86, 0x4f, 0x42, 0x0f, 0xe2, 0x2a, 0xa0,
	0x6e, 0xcd, 0x88, 0xb4, 0x63, 0x62, 0xe6, 0x0e, 0x1f, 0x98, 0x11, 0x98, 0x4f, 0xd1, 0x22, 0x92,
	0xa2, 0x9e, 0xa6, 0x67, 0x6d, 0xea, 0xf4, 0x64, 0x59, 0xc8, 0x24, 0xb2, 0xde, 0x3d, 0x1d, 0x7e,
	0x2f, 0x80, 0x69, 0x61, 0x77, 0x2f, 0xb4, 0xbb, 0x30, 0xc5, 0x9e, 0xf6, 0xb6, 0xec, 0x7d, 0xac,
	0xb0, 0x57, 0xa0, 0xcb, 0x8c, 0x64, 0x19, 0x45, 0x1e, 0x4e, 0x61, 0x1f, 0x54, 0x62, 0xa4, 0x84,
	0xc6, 0xe2, 0x4a, 0xb1, 0x5e, 0x59, 0x5d, 0x68, 0xb0, 0xf2, 0xdf, 0x88, 0xcb, 0x7f, 0x83, 0x57,
	0x7e, 0xea, 0xc0, 0xda, 0xcd, 0xe7, 0x27, 0xcb, 0x63, 0xbf, 0xfc, 0xb1, 0x5c, 0x77, 0x3d, 0x72,
	0x10, 0x75, 0x1a, 0x0e, 0xea, 0x37, 0xf9, 0x5d, 0xc1, 0xfe, 0xdc, 0xc0, 0xdd, 0x43, 0x7e, 0x23,
	0xc4, 0x0b, 0xb0, 0x25, 0xe3, 0xeb, 0xab, 0xa0, 0x12, 0x1b, 0x4f, 0xcc, 0xb1, 0x04, 0xbd, 0x24,
	0x67, 0x1a, 0xf5, 0x50, 0x9e, 0x14, 0x17, 0x9a, 0x8d, 0x67, 0x24, 0xb4, 0xdb, 0xfe, 0x3e, 0x4a,
	0x0a, 0x8d, 0x10, 0x48, 0x69, 0x32, 0x21, 0xa7, 0x89, 0xf9, 0x14, 0xcc, 0xa9, 0xd1, 0x15, 0xa4,
	0x5e, 0x07, 0x93, 0x2c, 0x28, 0x09, 0xa7, 0x95, 0xd3, 0x93, 0xe5, 0x44, 0x64, 0x25, 0x3f, 0xce,
	0xc1, 0xe8, 0x26, 0xbd, 0x29, 0x5a, 0x1e, 0xb6, 0x3b, 0xbd, 0xb7, 0x39, 0xe0, 0x43, 0xae, 0x3f,
	0x73, 0x0b, 0x54, 0xd3, 0x38, 0x23, 0xdc, 0x1e, 0xeb, 0xb4, 0xea, 0x70, 0x34, 0x96, 0x67, 0xd5,
	0x54, 0x04, 0x06, 0x9b, 0x1e, 0xe6, 0xd2, 0x7d, 0x7a, 0x46, 0x64, 0x90, 0x11, 0x3c, 0xda, 0xa0,
	0x1e, 0x6d, 0xf8, 0x23, 0x86, 0x89, 0xf9, 0x24, 0xc3, 0x8c, 0xe0, 0xd3, 0x1a, 0x3d, 0x8c, 0x0c,
	0xec, 0xbc, 0x41, 0xfa, 0x94, 0xa6, 0x9c, 0x84, 0x31, 0x82, 0x3f, 0xdf, 0xd0, 0x5c, 0x62, 0xaf,
	0x87, 0x11, 0x82, 0x14, 0x5b, 0xa6, 0xa7, 0xbd, 0xc5, 0xce, 0x76, 0xd9, 0x4a, 0x86, 0x66, 0x97,
	0x66, 0x99, 0x62, 0xe1, 0x6f, 0x78, 0x3d, 0x7d, 0x57, 0x00, 0x95, 0x6d, 0xec, 0x6e, 0x7a, 0x36,
	0x89, 0x0d, 0xbf, 0xf1, 0xd5, 0x72, 0x1b, 0x4c, 0xb6, 0x50, 0xd4, 0xe9, 0xc1, 0x4c, 0x21, 0x63,
	0xe2, 0xfb, 0xf0, 0xf8, 0xb1, 0xdd, 0x8b, 0x20, 0x2b, 0xe1, 0x7c, 0xaa, 0xde, 0x00, 0xa5, 0x2d,
	0xe4, 0xbb, 0xec, 0x40, 0x56, 0x56, 0xab, 0xe2, 0xe9, 0x80, 0x7c, 0x57, 0x59, 0xc1, 0xa6, 0xc5,
	0x56, 0x76, 0x49, 0xe8, 0xc5, 0x2b, 0xc6, 0x55, 0x2b, 0x4c, 0xac, 0x5a, 0xe1, 0x53, 0xa5, 0x18,
	0x97, 0xd2, 0x37, 0xd2, 0x5e, 0x68, 0xfb, 0x78, 0x1f, 0x86, 0x9b, 0x10, 0xd2, 0x3a, 0x54, 0xb4,
	0x64, 0x91, 0x79, 0x08, 0x66, 0xa4, 0x20, 0x88, 0x30, 0x9b, 0x60, 0x82, 0xb1, 0xc1, 0x0b, 0x11,
	0x38, 0x3d, 0x59, 0xe6, 0x12, 0x8b, 0xff, 0x3d, 0x47, 0x19, 0xfa, 0x8a, 0x1e, 0xaf, 0xcd, 0xa8,
	0xb7, 0xef, 0xf5, 0x7a, 0xe7, 0xcc, 0xe5, 0x33, 0xf2, 0x86, 0x1d, 0x3b, 0x19, 0x7e, 0x84, 0x34,
	0xff, 0x51, 0x03, 0x53, 0xdb, 0xd8, 0xfd, 0x04, 0x92, 0x1d, 0x1a, 0x7f, 0xdd, 0x01, 0x13, 0x77,
	0xfb, 0xf1, 0x1b, 0xbb, 0xaa, 0xbd, 0xff, 0xab, 0x88, 0x43, 0xab, 0xcf, 0xf7, 0x42, 0xfa, 0xf9,
	0x7e, 0x0f, 0xcc, 0xca, 0x2e, 0x8d, 0xf2, 0x70, 0xd7, 0xc0, 0x95, 0x18, 0x8a, 0x76, 0x62, 0xed,
	0xbb, 0x3b, 0x83, 0x6d, 0x2e, 0x81, 0xf2, 0x4e, 0x88, 0xba, 0x91, 0x43, 0x04, 0x25, 0x03, 0x01,
	0xed, 0x7f, 0xa2, 0xd0, 0x39, 0xb0, 0x31, 0xdc, 0x43, 0x87, 0xd0, 0xe7, 0xb0, 0xaa, 0x50, 0xff,
	0x1f, 0xb8, 0x6c, 0x41, 0x07, 0x7a, 0x01, 0x69, 0xd9, 0xc4, 0x5e, 0xb3, 0x31, 0xfc, 0xe8, 0x36,
	0x4f, 0x85, 0xac, 0x22, 0xb6, 0xb8, 0xeb, 0xb9, 0xbe, 0x4d, 0xa2, 0x10, 0xd2, 0xa4, 0x2f, 0x5b,
	0x03, 0x81, 0x1a, 0x91, 0x52, 0x3a, 0x22, 0x9f, 0x81, 0xab, 0xb9, 0xdb, 0x18, 0x21, 0x34, 0x3f,
	0x33, 0xe2, 0xe3, 0x6c, 0xa3, 0xdc, 0x7c, 0x18, 0xe2, 0x87, 0x65, 0x3b, 0xab, 0xac, 0xd0, 0x3b,
	0x82, 0x21, 0x8f, 0xa0, 0x18, 0x9b, 0x73, 0x34, 0x1d, 0x84, 0xa3, 0xc9, 0x9e, 0xcd, 0x2f, 0xc5,
	0x06, 0xe2, 0x93, 0x81, 0xe5, 0x13, 0xa3, 0x29, 0x27, 0xe6, 0x5c, 0x56, 0xef, 0x09, 0xab, 0x14,
	0x7d, 0x84, 0x48, 0x3f, 0xa5, 0xb5, 0xe7, 0x51, 0xd0, 0xb5, 0x09, 0x7d, 0x07, 0xb2, 0x6a, 0xa6,
	0xcf, 0x82, 0xd2, 0xa6, 0x07, 0x7b, 0x5d, 0x0e, 0xc3, 0x06, 0xb1, 0x94, 0x16, 0x3e, 0x8e, 0xc1,
	0x06, 0xd2, 0x06, 0x8a, 0xca, 0x06, 0xe6, 0x44, 0xfd, 0x62, 0x09, 0xc5, 0x47, 0xe6, 0x43, 0xb0,
	0x98, 0x63, 0x52, 0xec, 0x61, 0xe0, 0xa9, 0xa6, 0xdc, 0x21, 0x43, 0x4b, 0x9d, 0xf9, 0x52, 0xa3,
	0x1d, 0x30, 0x43, 0x14, 0x1d, 0xf0, 0x34, 0x28, 0x88, 0xd3, 0x53, 0x68, 0xb7, 0xd2, 0x9d, 0x41,
	0xe1, 0xcc, 0xee, 0xb6, 0xf8, 0x0e, 0xdd, 0xed, 0xf8, 0x9b, 0xba, 0xdb, 0xd2, 0x9b, 0xbb, 0xdb,
	0x61, 0xef, 0x54, 0xd6, 0x94, 0xaa, 0x3b, 0xfb, 0x80, 0x4d, 0xe9, 0xf7, 0xac, 0x29, 0x65, 0xf6,
	0xf9, 0x3b, 0x23, 0x69, 0x3c, 0xb5, 0xa1, 0x8d, 0x67, 0x21, 0x73, 0x6f, 0x33, 0x2e, 0x8a, 0x82,
	0x8b, 0x7f, 0x1a, 0xd1, 0xf3, 0x36, 0xa2, 0x32, 0x15, 0x1f, 0xa2, 0x11, 0x5d, 0xfd, 0x6d, 0x0a,
	0x14, 0xb7, 0xb1, 0xab, 0x3f, 0x01, 0xf3, 0xf7, 0x6c, 0xbf, 0xdb, 0x83, 0x61, 0xe6, 0x7b, 0x97,
	0x78, 0x50, 0xa5, 0x35, 0x86, 0x99, 0xd1, 0x64, 0xbf, 0x78, 0xb5, 0xc1, 0xcc, 0x00, 0x78, 0x70,
	0x07, 0xce, 0x4a, 0x4b, 0x85, 0xd4, 0x58, 0xca, 0x93, 0x0a, 0xa8, 0x2e, 0x58, 0x92, 0xa0, 0xb2,
	0xf7, 0xea, 0x55, 0x79, 0x75, 0x46, 0x6d, 0x5c, 0x3f, 0x53, 0x9d, 0xef, 0xf0, 0xe0, 0x8a, 0x92,
	0x1d, 0x16, 0x52, 0xc5, 0xe1, 0xcc, 0x2d, 0x91, 0x85, 0x62, 0x97, 0x45, 0x1a, 0x8a, 0x4a, 0x33,
	0x50, 0x6a, 0xe9, 0xff, 0x1c, 0x54, 0xd3, 0xfc, 0x88, 0x52, 0xb8, 0x90, 0xa1, 0x21, 0x51, 0x19,
	0xff, 0x1e, 0xaa, 0xca, 0x47, 0x4e, 0x15, 0x59, 0x19, 0x59, 0x55, 0x29, 0xc8, 0x43, 0x0a, 0x98,
	0x05, 0xe6, 0xd2, 0x3e, 0xf3, 0x22, 0x33, 0x9f, 0x71, 0x8b, 0x29, 0x8c, 0xe5, 0x21, 0x8a, 0x7c,
	0x4c, 0xa5, 0x70, 0xcd, 0x67, 0x1c, 0xca, 0xc1, 0xcc, 0x3d, 0x5f, 0x8f, 0xe4, 0xdc, 0x57, 0xbb,
	0x2e, 0x39, 0xf7, 0x15, 0x8d, 0xb1, 0x32, 0x4c, 0x93, 0x0f, 0xab, 0x7e, 0x18, 0x90, 0x61, 0x15,
	0x8d, 0x02, 0x9b, 0xff, 0x11, 0x40, 0x89, 0x80, 0xd2, 0x47, 0xcb, 0x11, 0x90, 0x15, 0x4a, 0x04,
	0x72, 0x5b, 0x66, 0x35, 0xbb, 0xd4, 0xef, 0xf7, 0x4a, 0x76, 0x29, 0x2a, 0x35, 0xbb, 0xf2, 0x3f,
	0xc5, 0x6f, 0x02, 0x7d, 0x80, 0x2c, 0x1a, 0xc1, 0x19, 0x69, 0x61, 0x22, 0x34, 0x16, 0x73, 0x84,
	0x02, 0xe7, 0x6b, 0x60, 0xa4, 0x79, 0x97, 0xde, 0x33, 0x8b, 0x19, 0x8a, 0x07, 0x4a, 0xe3, 0xda,
	0x19, 0x4a, 0x81, 0xff, 0x10, 0x5c, 0x49, 0xe7, 0x2a, 0xeb, 0x9e, 0xe6, 0x32, 0x19, 0x49, 0xe5,
	0x46, 0x2d, 0x5f, 0x9e, 0x4f, 0x93, 0xd2, 0x8f, 0xc9, 0x34, 0xc9, 0x0a, 0x85, 0xa6, 0xdc, 0x16,
	0x4b, 0xc1, 0x54, 0x3e, 0xea, 0xcc, 0x67, 0xd3, 0x26, 0x8b, 0x99, 0xfb, 0x05, 0x47, 0xd9, 0xb8,
	0xfc, 0x09, 0x64, 0x2e, 0x93, 0x34, 0xd9, 0x8d, 0xe7, 0x7c, 0xee, 0x58, 0xdb, 0x78, 0xfe, 0xaa,
	0xa6, 0xbd, 0x78, 0x55, 0xd3, 0xfe, 0x7c, 0x55, 0xd3, 0x7e, 0x78, 0x5d, 0x1b, 0x7b, 0xf1, 0xba,
	0x36, 0xf6, 0xf2, 0x75, 0x6d, 0xec, 0x8b, 0xff, 0x4a, 0x4f, 0x76, 0x56, 0x74, 0x6f, 0x10, 0xe8,
	0x1c, 0x34, 0xf9, 0x7f, 0x92, 0x9e, 0x35, 0xa5, 0xff, 0x80, 0x75, 0x26, 0xe8, 0xbf, 0x94, 0xfe,
	0xff, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9a, 0xbd, 0x8f, 0xa2, 0x17, 0x1b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// HandlerMsgCreateAccount is used to send pylons to requesters. This handler is part of the faucet
	HandlerMsgCreateAccount(ctx context.Context, in *MsgCreateAccount, opts ...grpc.CallOption) (*MsgCreateExecutionResponse, error)
	// HandlerMsgGetPylons is used to send pylons to requesters. This handler is part of the faucet
	HandlerMsgGetPylons(ctx context.Context, in *MsgGetPylons, opts ...grpc.CallOption) (*MsgGetPylonsResponse, error)
	// HandlerMsgGoogleIAPGetPylons is used to send pylons to requesters after google iap verification
	HandlerMsgGoogleIAPGetPylons(ctx context.Context, in *MsgGoogleIAPGetPylons, opts ...grpc.CallOption) (*MsgGoogleIAPGetPylonsResponse, error)
	// HandlerMsgSendCoins is used to transact pylons between people
	HandlerMsgSendCoins(ctx context.Context, in *MsgSendCoins, opts ...grpc.CallOption) (*MsgSendCoinsResponse, error)
	// HandlerMsgSendItems is used to send items between people
	HandlerMsgSendItems(ctx context.Context, in *MsgSendItems, opts ...grpc.CallOption) (*MsgSendItemsResponse, error)
	// HandlerMsgCreateCookbook is used to create cookbook by a developer
	HandlerMsgCreateCookbook(ctx context.Context, in *MsgCreateCookbook, opts ...grpc.CallOption) (*MsgCreateCookbookResponse, error)
	// HandlerMsgUpdateCookbook is used to update cookbook by a developer
	HandlerMsgUpdateCookbook(ctx context.Context, in *MsgUpdateCookbook, opts ...grpc.CallOption) (*MsgUpdateCookbookResponse, error)
	// HandlerMsgCreateRecipe is used to create recipe by a developer
	HandlerMsgCreateRecipe(ctx context.Context, in *MsgCreateRecipe, opts ...grpc.CallOption) (*MsgCreateRecipeResponse, error)
	// HandlerMsgUpdateRecipe is used to update recipe by a developer
	HandlerMsgUpdateRecipe(ctx context.Context, in *MsgUpdateRecipe, opts ...grpc.CallOption) (*MsgUpdateRecipeResponse, error)
	// HandlerMsgExecuteRecipe is used to execute a recipe
	HandlerMsgExecuteRecipe(ctx context.Context, in *MsgExecuteRecipe, opts ...grpc.CallOption) (*MsgExecuteRecipeResponse, error)
	// HandlerMsgDisableRecipe is used to disable recipe by a developer
	HandlerMsgDisableRecipe(ctx context.Context, in *MsgDisableRecipe, opts ...grpc.CallOption) (*MsgDisableRecipeResponse, error)
	// HandlerMsgEnableRecipe is used to enable recipe by a developer
	HandlerMsgEnableRecipe(ctx context.Context, in *MsgEnableRecipe, opts ...grpc.CallOption) (*MsgEnableRecipeResponse, error)
	// HandlerMsgCheckExecution is used to check the status of an execution
	HandlerMsgCheckExecution(ctx context.Context, in *MsgCheckExecution, opts ...grpc.CallOption) (*MsgCheckExecutionResponse, error)
	// HandlerMsgFiatItem is used to create item within 1 block execution
	HandlerMsgFiatItem(ctx context.Context, in *MsgFiatItem, opts ...grpc.CallOption) (*MsgFiatItemResponse, error)
	// HandlerMsgUpdateItemString is used to transact pylons between people
	HandlerMsgUpdateItemString(ctx context.Context, in *MsgUpdateItemString, opts ...grpc.CallOption) (*MsgUpdateItemStringResponse, error)
	// HandlerMsgCreateTrade is used to create a trade by a user
	HandlerMsgCreateTrade(ctx context.Context, in *MsgCreateTrade, opts ...grpc.CallOption) (*MsgCreateTradeResponse, error)
	// HandlerMsgFulfillTrade is used to fulfill a trade
	HandlerMsgFulfillTrade(ctx context.Context, in *MsgFulfillTrade, opts ...grpc.CallOption) (*MsgFulfillTradeResponse, error)
	// HandlerMsgDisableTrade is used to enable trade by a developer
	HandlerMsgDisableTrade(ctx context.Context, in *MsgDisableTrade, opts ...grpc.CallOption) (*MsgDisableTradeResponse, error)
	// HandlerMsgEnableTrade is used to enable trade by a developer
	HandlerMsgEnableTrade(ctx context.Context, in *MsgEnableTrade, opts ...grpc.CallOption) (*MsgEnableTradeResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) HandlerMsgCreateAccount(ctx context.Context, in *MsgCreateAccount, opts ...grpc.CallOption) (*MsgCreateExecutionResponse, error) {
	out := new(MsgCreateExecutionResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgCreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgGetPylons(ctx context.Context, in *MsgGetPylons, opts ...grpc.CallOption) (*MsgGetPylonsResponse, error) {
	out := new(MsgGetPylonsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgGetPylons", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgGoogleIAPGetPylons(ctx context.Context, in *MsgGoogleIAPGetPylons, opts ...grpc.CallOption) (*MsgGoogleIAPGetPylonsResponse, error) {
	out := new(MsgGoogleIAPGetPylonsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgGoogleIAPGetPylons", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgSendCoins(ctx context.Context, in *MsgSendCoins, opts ...grpc.CallOption) (*MsgSendCoinsResponse, error) {
	out := new(MsgSendCoinsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgSendCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgSendItems(ctx context.Context, in *MsgSendItems, opts ...grpc.CallOption) (*MsgSendItemsResponse, error) {
	out := new(MsgSendItemsResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgSendItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgCreateCookbook(ctx context.Context, in *MsgCreateCookbook, opts ...grpc.CallOption) (*MsgCreateCookbookResponse, error) {
	out := new(MsgCreateCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgCreateCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgUpdateCookbook(ctx context.Context, in *MsgUpdateCookbook, opts ...grpc.CallOption) (*MsgUpdateCookbookResponse, error) {
	out := new(MsgUpdateCookbookResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgUpdateCookbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgCreateRecipe(ctx context.Context, in *MsgCreateRecipe, opts ...grpc.CallOption) (*MsgCreateRecipeResponse, error) {
	out := new(MsgCreateRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgCreateRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgUpdateRecipe(ctx context.Context, in *MsgUpdateRecipe, opts ...grpc.CallOption) (*MsgUpdateRecipeResponse, error) {
	out := new(MsgUpdateRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgUpdateRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgExecuteRecipe(ctx context.Context, in *MsgExecuteRecipe, opts ...grpc.CallOption) (*MsgExecuteRecipeResponse, error) {
	out := new(MsgExecuteRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgExecuteRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgDisableRecipe(ctx context.Context, in *MsgDisableRecipe, opts ...grpc.CallOption) (*MsgDisableRecipeResponse, error) {
	out := new(MsgDisableRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgDisableRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgEnableRecipe(ctx context.Context, in *MsgEnableRecipe, opts ...grpc.CallOption) (*MsgEnableRecipeResponse, error) {
	out := new(MsgEnableRecipeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgEnableRecipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgCheckExecution(ctx context.Context, in *MsgCheckExecution, opts ...grpc.CallOption) (*MsgCheckExecutionResponse, error) {
	out := new(MsgCheckExecutionResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgCheckExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgFiatItem(ctx context.Context, in *MsgFiatItem, opts ...grpc.CallOption) (*MsgFiatItemResponse, error) {
	out := new(MsgFiatItemResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgFiatItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgUpdateItemString(ctx context.Context, in *MsgUpdateItemString, opts ...grpc.CallOption) (*MsgUpdateItemStringResponse, error) {
	out := new(MsgUpdateItemStringResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgUpdateItemString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgCreateTrade(ctx context.Context, in *MsgCreateTrade, opts ...grpc.CallOption) (*MsgCreateTradeResponse, error) {
	out := new(MsgCreateTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgCreateTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgFulfillTrade(ctx context.Context, in *MsgFulfillTrade, opts ...grpc.CallOption) (*MsgFulfillTradeResponse, error) {
	out := new(MsgFulfillTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgFulfillTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgDisableTrade(ctx context.Context, in *MsgDisableTrade, opts ...grpc.CallOption) (*MsgDisableTradeResponse, error) {
	out := new(MsgDisableTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgDisableTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandlerMsgEnableTrade(ctx context.Context, in *MsgEnableTrade, opts ...grpc.CallOption) (*MsgEnableTradeResponse, error) {
	out := new(MsgEnableTradeResponse)
	err := c.cc.Invoke(ctx, "/pylons.Msg/HandlerMsgEnableTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// HandlerMsgCreateAccount is used to send pylons to requesters. This handler is part of the faucet
	HandlerMsgCreateAccount(context.Context, *MsgCreateAccount) (*MsgCreateExecutionResponse, error)
	// HandlerMsgGetPylons is used to send pylons to requesters. This handler is part of the faucet
	HandlerMsgGetPylons(context.Context, *MsgGetPylons) (*MsgGetPylonsResponse, error)
	// HandlerMsgGoogleIAPGetPylons is used to send pylons to requesters after google iap verification
	HandlerMsgGoogleIAPGetPylons(context.Context, *MsgGoogleIAPGetPylons) (*MsgGoogleIAPGetPylonsResponse, error)
	// HandlerMsgSendCoins is used to transact pylons between people
	HandlerMsgSendCoins(context.Context, *MsgSendCoins) (*MsgSendCoinsResponse, error)
	// HandlerMsgSendItems is used to send items between people
	HandlerMsgSendItems(context.Context, *MsgSendItems) (*MsgSendItemsResponse, error)
	// HandlerMsgCreateCookbook is used to create cookbook by a developer
	HandlerMsgCreateCookbook(context.Context, *MsgCreateCookbook) (*MsgCreateCookbookResponse, error)
	// HandlerMsgUpdateCookbook is used to update cookbook by a developer
	HandlerMsgUpdateCookbook(context.Context, *MsgUpdateCookbook) (*MsgUpdateCookbookResponse, error)
	// HandlerMsgCreateRecipe is used to create recipe by a developer
	HandlerMsgCreateRecipe(context.Context, *MsgCreateRecipe) (*MsgCreateRecipeResponse, error)
	// HandlerMsgUpdateRecipe is used to update recipe by a developer
	HandlerMsgUpdateRecipe(context.Context, *MsgUpdateRecipe) (*MsgUpdateRecipeResponse, error)
	// HandlerMsgExecuteRecipe is used to execute a recipe
	HandlerMsgExecuteRecipe(context.Context, *MsgExecuteRecipe) (*MsgExecuteRecipeResponse, error)
	// HandlerMsgDisableRecipe is used to disable recipe by a developer
	HandlerMsgDisableRecipe(context.Context, *MsgDisableRecipe) (*MsgDisableRecipeResponse, error)
	// HandlerMsgEnableRecipe is used to enable recipe by a developer
	HandlerMsgEnableRecipe(context.Context, *MsgEnableRecipe) (*MsgEnableRecipeResponse, error)
	// HandlerMsgCheckExecution is used to check the status of an execution
	HandlerMsgCheckExecution(context.Context, *MsgCheckExecution) (*MsgCheckExecutionResponse, error)
	// HandlerMsgFiatItem is used to create item within 1 block execution
	HandlerMsgFiatItem(context.Context, *MsgFiatItem) (*MsgFiatItemResponse, error)
	// HandlerMsgUpdateItemString is used to transact pylons between people
	HandlerMsgUpdateItemString(context.Context, *MsgUpdateItemString) (*MsgUpdateItemStringResponse, error)
	// HandlerMsgCreateTrade is used to create a trade by a user
	HandlerMsgCreateTrade(context.Context, *MsgCreateTrade) (*MsgCreateTradeResponse, error)
	// HandlerMsgFulfillTrade is used to fulfill a trade
	HandlerMsgFulfillTrade(context.Context, *MsgFulfillTrade) (*MsgFulfillTradeResponse, error)
	// HandlerMsgDisableTrade is used to enable trade by a developer
	HandlerMsgDisableTrade(context.Context, *MsgDisableTrade) (*MsgDisableTradeResponse, error)
	// HandlerMsgEnableTrade is used to enable trade by a developer
	HandlerMsgEnableTrade(context.Context, *MsgEnableTrade) (*MsgEnableTradeResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) HandlerMsgCreateAccount(ctx context.Context, req *MsgCreateAccount) (*MsgCreateExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgCreateAccount not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgGetPylons(ctx context.Context, req *MsgGetPylons) (*MsgGetPylonsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgGetPylons not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgGoogleIAPGetPylons(ctx context.Context, req *MsgGoogleIAPGetPylons) (*MsgGoogleIAPGetPylonsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgGoogleIAPGetPylons not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgSendCoins(ctx context.Context, req *MsgSendCoins) (*MsgSendCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgSendCoins not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgSendItems(ctx context.Context, req *MsgSendItems) (*MsgSendItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgSendItems not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgCreateCookbook(ctx context.Context, req *MsgCreateCookbook) (*MsgCreateCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgCreateCookbook not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgUpdateCookbook(ctx context.Context, req *MsgUpdateCookbook) (*MsgUpdateCookbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgUpdateCookbook not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgCreateRecipe(ctx context.Context, req *MsgCreateRecipe) (*MsgCreateRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgCreateRecipe not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgUpdateRecipe(ctx context.Context, req *MsgUpdateRecipe) (*MsgUpdateRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgUpdateRecipe not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgExecuteRecipe(ctx context.Context, req *MsgExecuteRecipe) (*MsgExecuteRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgExecuteRecipe not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgDisableRecipe(ctx context.Context, req *MsgDisableRecipe) (*MsgDisableRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgDisableRecipe not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgEnableRecipe(ctx context.Context, req *MsgEnableRecipe) (*MsgEnableRecipeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgEnableRecipe not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgCheckExecution(ctx context.Context, req *MsgCheckExecution) (*MsgCheckExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgCheckExecution not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgFiatItem(ctx context.Context, req *MsgFiatItem) (*MsgFiatItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgFiatItem not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgUpdateItemString(ctx context.Context, req *MsgUpdateItemString) (*MsgUpdateItemStringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgUpdateItemString not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgCreateTrade(ctx context.Context, req *MsgCreateTrade) (*MsgCreateTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgCreateTrade not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgFulfillTrade(ctx context.Context, req *MsgFulfillTrade) (*MsgFulfillTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgFulfillTrade not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgDisableTrade(ctx context.Context, req *MsgDisableTrade) (*MsgDisableTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgDisableTrade not implemented")
}
func (*UnimplementedMsgServer) HandlerMsgEnableTrade(ctx context.Context, req *MsgEnableTrade) (*MsgEnableTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlerMsgEnableTrade not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_HandlerMsgCreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgCreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgCreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgCreateAccount(ctx, req.(*MsgCreateAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgGetPylons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetPylons)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgGetPylons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgGetPylons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgGetPylons(ctx, req.(*MsgGetPylons))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgGoogleIAPGetPylons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGoogleIAPGetPylons)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgGoogleIAPGetPylons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgGoogleIAPGetPylons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgGoogleIAPGetPylons(ctx, req.(*MsgGoogleIAPGetPylons))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgSendCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendCoins)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgSendCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgSendCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgSendCoins(ctx, req.(*MsgSendCoins))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgSendItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendItems)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgSendItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgSendItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgSendItems(ctx, req.(*MsgSendItems))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgCreateCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCookbook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgCreateCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgCreateCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgCreateCookbook(ctx, req.(*MsgCreateCookbook))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgUpdateCookbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCookbook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgUpdateCookbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgUpdateCookbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgUpdateCookbook(ctx, req.(*MsgUpdateCookbook))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgCreateRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateRecipe)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgCreateRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgCreateRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgCreateRecipe(ctx, req.(*MsgCreateRecipe))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgUpdateRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateRecipe)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgUpdateRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgUpdateRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgUpdateRecipe(ctx, req.(*MsgUpdateRecipe))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgExecuteRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExecuteRecipe)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgExecuteRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgExecuteRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgExecuteRecipe(ctx, req.(*MsgExecuteRecipe))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgDisableRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisableRecipe)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgDisableRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgDisableRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgDisableRecipe(ctx, req.(*MsgDisableRecipe))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgEnableRecipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEnableRecipe)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgEnableRecipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgEnableRecipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgEnableRecipe(ctx, req.(*MsgEnableRecipe))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgCheckExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCheckExecution)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgCheckExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgCheckExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgCheckExecution(ctx, req.(*MsgCheckExecution))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgFiatItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFiatItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgFiatItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgFiatItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgFiatItem(ctx, req.(*MsgFiatItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgUpdateItemString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateItemString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgUpdateItemString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgUpdateItemString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgUpdateItemString(ctx, req.(*MsgUpdateItemString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgCreateTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgCreateTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgCreateTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgCreateTrade(ctx, req.(*MsgCreateTrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgFulfillTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfillTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgFulfillTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgFulfillTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgFulfillTrade(ctx, req.(*MsgFulfillTrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgDisableTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisableTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgDisableTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgDisableTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgDisableTrade(ctx, req.(*MsgDisableTrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandlerMsgEnableTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEnableTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandlerMsgEnableTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pylons.Msg/HandlerMsgEnableTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandlerMsgEnableTrade(ctx, req.(*MsgEnableTrade))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pylons.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandlerMsgCreateAccount",
			Handler:    _Msg_HandlerMsgCreateAccount_Handler,
		},
		{
			MethodName: "HandlerMsgGetPylons",
			Handler:    _Msg_HandlerMsgGetPylons_Handler,
		},
		{
			MethodName: "HandlerMsgGoogleIAPGetPylons",
			Handler:    _Msg_HandlerMsgGoogleIAPGetPylons_Handler,
		},
		{
			MethodName: "HandlerMsgSendCoins",
			Handler:    _Msg_HandlerMsgSendCoins_Handler,
		},
		{
			MethodName: "HandlerMsgSendItems",
			Handler:    _Msg_HandlerMsgSendItems_Handler,
		},
		{
			MethodName: "HandlerMsgCreateCookbook",
			Handler:    _Msg_HandlerMsgCreateCookbook_Handler,
		},
		{
			MethodName: "HandlerMsgUpdateCookbook",
			Handler:    _Msg_HandlerMsgUpdateCookbook_Handler,
		},
		{
			MethodName: "HandlerMsgCreateRecipe",
			Handler:    _Msg_HandlerMsgCreateRecipe_Handler,
		},
		{
			MethodName: "HandlerMsgUpdateRecipe",
			Handler:    _Msg_HandlerMsgUpdateRecipe_Handler,
		},
		{
			MethodName: "HandlerMsgExecuteRecipe",
			Handler:    _Msg_HandlerMsgExecuteRecipe_Handler,
		},
		{
			MethodName: "HandlerMsgDisableRecipe",
			Handler:    _Msg_HandlerMsgDisableRecipe_Handler,
		},
		{
			MethodName: "HandlerMsgEnableRecipe",
			Handler:    _Msg_HandlerMsgEnableRecipe_Handler,
		},
		{
			MethodName: "HandlerMsgCheckExecution",
			Handler:    _Msg_HandlerMsgCheckExecution_Handler,
		},
		{
			MethodName: "HandlerMsgFiatItem",
			Handler:    _Msg_HandlerMsgFiatItem_Handler,
		},
		{
			MethodName: "HandlerMsgUpdateItemString",
			Handler:    _Msg_HandlerMsgUpdateItemString_Handler,
		},
		{
			MethodName: "HandlerMsgCreateTrade",
			Handler:    _Msg_HandlerMsgCreateTrade_Handler,
		},
		{
			MethodName: "HandlerMsgFulfillTrade",
			Handler:    _Msg_HandlerMsgFulfillTrade_Handler,
		},
		{
			MethodName: "HandlerMsgDisableTrade",
			Handler:    _Msg_HandlerMsgDisableTrade_Handler,
		},
		{
			MethodName: "HandlerMsgEnableTrade",
			Handler:    _Msg_HandlerMsgEnableTrade_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pylons/msgs.proto",
}

func (m *MsgCheckExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCheckExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCheckExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayToComplete {
		i--
		if m.PayToComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExecID) > 0 {
		i -= len(m.ExecID)
		copy(dAtA[i:], m.ExecID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ExecID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCheckExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCheckExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCheckExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCookbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCookbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCookbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CostPerBlock != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.CostPerBlock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.Level != nil {
		{
			size, err := m.Level.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SupportEmail != nil {
		{
			size, err := m.SupportEmail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockInterval != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x38
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExtraInfo) > 0 {
		i -= len(m.ExtraInfo)
		copy(dAtA[i:], m.ExtraInfo)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ExtraInfo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ItemOutputs != nil {
		{
			size, err := m.ItemOutputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CoinOutputs) > 0 {
		for iNdEx := len(m.CoinOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEnableTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEnableTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEnableTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExecuteRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExecuteRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExecuteRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExecuteRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExecuteRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExecuteRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFiatItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFiatItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFiatItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransferFee != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.TransferFee))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Strings != nil {
		{
			size, err := m.Strings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Longs != nil {
		{
			size, err := m.Longs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Doubles != nil {
		{
			size, err := m.Doubles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFiatItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFiatItemResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFiatItemResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfillTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfillTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfillTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfillTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfillTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfillTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGetPylons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPylons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGetPylons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgGetPylonsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPylonsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGetPylonsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGoogleIAPGetPylons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGoogleIAPGetPylons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGoogleIAPGetPylons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReceiptDataBase64) > 0 {
		i -= len(m.ReceiptDataBase64)
		copy(dAtA[i:], m.ReceiptDataBase64)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ReceiptDataBase64)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PurchaseToken) > 0 {
		i -= len(m.PurchaseToken)
		copy(dAtA[i:], m.PurchaseToken)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.PurchaseToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductID) > 0 {
		i -= len(m.ProductID)
		copy(dAtA[i:], m.ProductID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ProductID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGoogleIAPGetPylonsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGoogleIAPGetPylonsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGoogleIAPGetPylonsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendCoins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendCoins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendCoinsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendCoinsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendCoinsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSendItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ItemIDs) > 0 {
		for iNdEx := len(m.ItemIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ItemIDs[iNdEx])
			copy(dAtA[i:], m.ItemIDs[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendItemsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendItemsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendItemsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateItemString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateItemString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateItemString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemID) > 0 {
		i -= len(m.ItemID)
		copy(dAtA[i:], m.ItemID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ItemID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateItemStringResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateItemStringResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateItemStringResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCookbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCookbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCookbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if m.SupportEmail != nil {
		{
			size, err := m.SupportEmail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCookbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCookbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCookbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRecipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRecipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if m.BlockInterval != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x38
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ItemInputs != nil {
		{
			size, err := m.ItemInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinInputs != nil {
		{
			size, err := m.CoinInputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CookbookID) > 0 {
		i -= len(m.CookbookID)
		copy(dAtA[i:], m.CookbookID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.CookbookID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRecipeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRecipeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRecipeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecipeID) > 0 {
		i -= len(m.RecipeID)
		copy(dAtA[i:], m.RecipeID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.RecipeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgs(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCheckExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.PayToComplete {
		n += 2
	}
	return n
}

func (m *MsgCheckExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateCookbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.SupportEmail != nil {
		l = m.SupportEmail.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Level != nil {
		l = m.Level.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CostPerBlock != 0 {
		n += 1 + sovMsgs(uint64(m.CostPerBlock))
	}
	return n
}

func (m *MsgCreateCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovMsgs(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.CoinOutputs) > 0 {
		for _, e := range m.CoinOutputs {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	if m.ItemOutputs != nil {
		l = m.ItemOutputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ExtraInfo)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgCreateTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDisableTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEnableTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgExecuteRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgExecuteRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgFiatItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Doubles != nil {
		l = m.Doubles.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Longs != nil {
		l = m.Longs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Strings != nil {
		l = m.Strings.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.TransferFee != 0 {
		n += 1 + sovMsgs(uint64(m.TransferFee))
	}
	return n
}

func (m *MsgFiatItemResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgFulfillTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgFulfillTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgGetPylons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgGetPylonsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgGoogleIAPGetPylons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.PurchaseToken)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ReceiptDataBase64)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgGoogleIAPGetPylonsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgSendCoins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgSendCoinsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSendItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		for _, s := range m.ItemIDs {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgSendItemsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateItemString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateItemStringResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateCookbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.SupportEmail != nil {
		l = m.SupportEmail.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateCookbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateRecipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.CookbookID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.CoinInputs != nil {
		l = m.CoinInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ItemInputs != nil {
		l = m.ItemInputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovMsgs(uint64(m.BlockInterval))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgUpdateRecipeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipeID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func sovMsgs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgs(x uint64) (n int) {
	return sovMsgs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCheckExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCheckExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCheckExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayToComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayToComplete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCheckExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCheckExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCheckExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output[:0], dAtA[iNdEx:postIndex]...)
			if m.Output == nil {
				m.Output = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCookbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCookbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCookbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &types.SemVer{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportEmail == nil {
				m.SupportEmail = &types.Email{}
			}
			if err := m.SupportEmail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Level == nil {
				m.Level = &types.Level{}
			}
			if err := m.Level.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostPerBlock", wireType)
			}
			m.CostPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.ItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &types.WeightedOutputsList{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = &types.EntriesList{}
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.TradeItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinOutputs = append(m.CoinOutputs, types1.Coin{})
			if err := m.CoinOutputs[len(m.CoinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemOutputs == nil {
				m.ItemOutputs = &types.ItemList{}
			}
			if err := m.ItemOutputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEnableTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEnableTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEnableTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExecuteRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExecuteRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExecuteRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExecuteRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExecuteRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExecuteRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output[:0], dAtA[iNdEx:postIndex]...)
			if m.Output == nil {
				m.Output = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFiatItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFiatItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFiatItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doubles == nil {
				m.Doubles = &types.DoubleKeyValueList{}
			}
			if err := m.Doubles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Longs == nil {
				m.Longs = &types.LongKeyValueList{}
			}
			if err := m.Longs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = &types.StringKeyValueList{}
			}
			if err := m.Strings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			m.TransferFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFiatItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFiatItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFiatItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfillTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfillTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfillTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfillTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfillTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfillTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPylons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPylons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPylons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPylonsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPylonsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPylonsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGoogleIAPGetPylons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchaseToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptDataBase64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptDataBase64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGoogleIAPGetPylonsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylonsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGoogleIAPGetPylonsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendCoinsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendCoinsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendCoinsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIDs = append(m.ItemIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendItemsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendItemsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendItemsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateItemString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateItemString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateItemString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateItemStringResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateItemStringResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateItemStringResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCookbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCookbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCookbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &types.SemVer{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportEmail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportEmail == nil {
				m.SupportEmail = &types.Email{}
			}
			if err := m.SupportEmail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCookbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCookbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCookbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookbookID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookbookID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinInputs == nil {
				m.CoinInputs = &types.CoinInputList{}
			}
			if err := m.CoinInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInputs == nil {
				m.ItemInputs = &types.ItemInputList{}
			}
			if err := m.ItemInputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &types.WeightedOutputsList{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = &types.EntriesList{}
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRecipeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRecipeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRecipeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgs = fmt.Errorf("proto: unexpected end of group")
)

/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements the Signature API to help in comparing when two
 * Plottable objects have "changed".
 *
 * Memoization in Plottable is complicated by mutable scales and datasets. We cannot simply
 * reference compare two e.g. scales since it may have internally mutated. To resolve this,
 * we write a recursive Signature interface that holds an immutable snapshot of whatever
 * state the scale/data was in at the time. Then on memoized function invocation we sign the
 * new inputs and compare the signatures to decide if we should recompute.
 *
 * We must hand-write a signature for each custom class we wish to support.
 */
import { Dataset } from "../core/dataset";
import { Scale } from "../scales/scale";
/**
 * Generic signature factory - pass any value and get a signature for it.
 *
 * Datasets and Scales are handled specially - see their respective signing methods.
 *
 * If the input is already a signature, simply return it.
 *
 * @param a
 * @returns {Signature}
 */
export declare function sign(a: any): Signature;
export declare function signScale(scale: Scale<any, any>): ObjectSignature;
export declare function signDataset(dataset: Dataset): ObjectSignature;
export declare function signRef(a: any): ReferenceSignature;
export declare function signArray(a: any[]): ArraySignature;
export declare function signObj(obj: {
    [key: string]: any;
}): ObjectSignature;
/**
 * Base signature. Subclasses should implement isSignatureDifferent. All classes
 * should be immutable.
 *
 * Users should only call `isDifferent`, not `isSignatureDifferent`.
 */
export declare abstract class Signature {
    isDifferent(other: Signature): boolean;
    protected abstract isSignatureDifferent(other: this): boolean;
}
/**
 * A signature for an array.
 */
export declare class ArraySignature extends Signature {
    private array;
    constructor(array: Signature[]);
    /**
     * An array of signatures is different if any of the elements isDifferent.
     */
    isSignatureDifferent(other: ArraySignature): boolean;
}
export declare class ReferenceSignature extends Signature {
    private ref;
    constructor(ref: any);
    isSignatureDifferent(other: ReferenceSignature): boolean;
}
export declare type ISignatureRecord = Record<string, Signature>;
/**
 * A signature for a plain js object.
 */
export declare class ObjectSignature extends Signature {
    private obj;
    constructor(obj: ISignatureRecord);
    /**
     * An object signature is different if any of the elements isDifferent.
     */
    isSignatureDifferent(other: ObjectSignature): boolean;
}
